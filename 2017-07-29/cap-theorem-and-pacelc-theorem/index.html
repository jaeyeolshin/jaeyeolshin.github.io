<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CAP 이론과 PACELC 이론을 알아보자 · 어쩌다 프로그래머</title><meta name="description" content="CAP 이론과 PACELC 이론을 알아보자 - Jaeyeol Shin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="어쩌다 프로그래머"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">CAP 이론과 PACELC 이론을 알아보자</h1><div class="post-info">Jul 29, 2017</div><div class="post-content"><p>지지난주 3일동안 동미참 훈련을 받았다. 예비군 훈련이 끝나고 남는 저녁 시간에 뭘할까 하다가 ‘언젠가 공부해야지’하고 생각만하던 것들을 공부하기로 하였다. 포부는 컸으나 3일 동안 <a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank" rel="external">CAP 이론</a> 관련 자료만 몇 개 본 게 전부였다. 그마저도 블로그에 정리하는 것을 미루고 미루다 이제야 정리를 한다.<a id="more"></a></p>
<p>이번에 CAP 이론을 공부하면서 가장 많이 참고한 자료는 <a href="https://www.youtube.com/watch?v=hUd_9FENShA" target="_blank" rel="external">CAP Theorem: You don’t need CP, you don’t want AP, and you can’t have CA</a>라는 싯다르타 레디(Siddhartha Reddy)의 영상이다. 영어라 듣기가 조금 어려웠지만 내용 자체는 어렵지 않고, 강의 자료가 내용을 이해하는데 많은 도움이 되었다. 사실 이 글도 영상의 내용을 정리하고 부가 내용을 조금 더한 것에 지나지 않는다. 강의 자료는 <a href="https://speakerdeck.com/sids/cap-theorem-you-dont-need-cp-you-dont-want-ap-and-you-cant-have-ca" target="_blank" rel="external">Speaker Deck</a>에 올라와 있으며 이 글 마지막에 첨부하였다.</p>
<h1 id="CAP-이론"><a href="#CAP-이론" class="headerlink" title="CAP 이론"></a>CAP 이론</h1><p><a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank" rel="external">CAP 이론</a>에서 CAP은 분산 데이터베이스 시스템의 세 가지 속성인 일관성(Consistency), 가용성(Availability), 파티션 허용성(Partition tolerance)을 나타낸다. 각각의 정의는 다음과 같다.</p>
<table>
<thead>
<tr>
<th>속성</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>일관성</strong></td>
<td>모든 요청은 최신 데이터 또는 에러를 응답받는다.</td>
</tr>
<tr>
<td><strong>가용성</strong></td>
<td>모든 요청은 정상 응답을 받는다.</td>
</tr>
<tr>
<td><strong>파티션 허용성</strong></td>
<td>노드간 통신이 실패하는 경우라도 시스템은 정상 동작 한다.</td>
</tr>
</tbody>
</table>
<p>여기서 말하는 일관성은 <a href="https://en.wikipedia.org/wiki/ACID" target="_blank" rel="external">ACID</a>의 일관성과는 다르다. ACID의 일관성은 데이터베이스에서 트랜잭션이 완료되었을 때 기존의 제약(무결성 등)을 위반하지 않아야 함을 의미한다. 만약 트랜잭션이 제약을 위반한다면 그 트랜잭션은 실패해야한다.</p>
<p>CAP 이론에 따르면 <strong>분산 데이터베이스 시스템은 네트워크 파티션이 발생하였을 때 세 가지 속성 중 두 가지만 만족할 수 있다.</strong> 세 가지 속성 중 두 가지를 만족하는 시스템은 CA(Consistency-Availability), CP(Consistency-Partition tolerance), AP(Availability-Partition tolerance) 세 종류로 나눌 수 있다. 하지만 CAP 이론은 네트워크 파티션 상황을 가정하므로 CA 시스템은 있을 수 없다. CA 시스템이 가능하려면 네트워크 파티션이 없어야 하는데 네트워크 파티션이 없으면 CAP 이론 자체가 쓸모 없을 뿐더러, 네트워크 파티션은 어떤 이유에서든 발생할 수 있다. 여기서 말하는 네트워크 파티션(Network Partition)은 물리적인 네트워크의 분할만을 의미하는 것이 아니다. 분산 시스템에서 노드끼리 데이터를 주고 받을 때 타임아웃이 발생하는 모든 경우를 네트워크 파티션으로 볼 수 있다. 타임아웃은 하드웨어의 문제 뿐만 아니라 방화벽 설정 오류, Java의 Garbage Collection 등 다양한 이유로 발생할 수 있다. 이런 이유로 우리는 네트워크 파티션이 없는 분산 시스템을 가정할 수 없으며, CAP 이론은 이러한 상황에서 분산 데이터베이스 시스템이 일관성(CP)과 가용성(AP) 둘 중에 하나만 만족할 수 있음을 설명한다.</p>
<h1 id="CAP-이론의-한계"><a href="#CAP-이론의-한계" class="headerlink" title="CAP 이론의 한계"></a>CAP 이론의 한계</h1><p>CAP 이론은 분산 시스템의 성질을 너무나도 단순명료하게 설명해준다. 하지만 이 단순함때문에 CAP 이론은 한계를 갖는다. CAP 이론에 따르면 분산 시스템은 CP이거나 AP여야 한다. 하지만 실제 시스템은 둘 중에 하나라고 명확히 구분지을 수 없으며, 완벽한 CP시스템이나 완벽한 AP시스템은 사실상 쓸모가 없다. 하나씩 살펴보자.</p>
<ul>
<li><strong>완벽한 CP시스템</strong> - 완벽한 일관성을 갖는 분산 시스템에서는 하나의 트랜잭션이 다른 모든 노드에 복제된 후에 완료될 수 있다. 이는 가용성 뿐만 아니라 성능의 희생을 필요로 한다. 이런 시스템은 하나의 노드라도 문제가 있으면 트랜잭션은 무조건 실패하고, 노드가 늘어날 수록 지연시간은 길어질 것이다.</li>
<li><strong>완벽한 AP시스템</strong> - 완벽한 가용성을 갖는 시스템은 모든 노드가 어떤 상황에서라도 응답할 수 있어야 한다. 하나의 노드가 네트워크 파티션으로 인해 고립되었다고 생각해보자. 이런 상황에서 고립된 노드가 갖고 있는 데이터는 쓸모가 없어지지만(일관성이 깨지므로) 어쨌든 응답한다면 완벽한 가용성을 갖게 된다. 운 나쁘게 이 노드와 연결된 사용자는 문제를 인지하지 못하고 계속해서 요청을 보낼 것이다.</li>
</ul>
<p>따라서 더 나은 CAP 이론의 해석은 <strong>‘일관성과 가용성은 상충 관계에 있지만 둘 중에 반드시 하나만을 선택해야 하는 것은 아니다’</strong> 이다. 완벽한 CP시스템과 완벽한 AP시스템 사이에는 수많은 가능성이 있다. 요구 사항에 따라 ‘다소 강한 일관성-다소 약한 가용성’, ‘다소 약한 일관성-다소 강한 가용성’과 같이 일관성과 가용성의 수준을 선택해야 한다.<br><img src="/images/cap-theorem-and-pacelc/cap.png" alt="일관성-가용성 스펙트럼"></p>
<p>CAP 이론의 또 다른 한계는 파티션이 없는 상황을 설명하지 못한다는 것이다. 파티션이 없는 상황에서도 분산 시스템은 상충하는 특성들이 있고, 장애 상황만큼이나 정상 상황에서 시스템이 어떻게 동작하는지도 중요하다.</p>
<h1 id="PACELC-이론"><a href="#PACELC-이론" class="headerlink" title="PACELC 이론"></a>PACELC 이론</h1><p>CAP 이론의 이러한 단점들을 보완하기 위해 나온 이론이 바로 <a href="https://en.wikipedia.org/wiki/PACELC_theorem" target="_blank" rel="external">PACELC 이론</a>이다. CAP 이론이 네트워크 파티션 상황에서 일관성-가용성 축을 이용하여 시스템의 특성을 설명한다면, PACELC 이론은 거기에 정상 상황이라는 새로운 축을 더한다. PACELC는 P(네트워크 파티션)상황에서 A(가용성)과 C(일관성)의 상충 관계와 E(else, 정상)상황에서 L(지연 시간)과 C(일관성)의 상충 관계를 설명한다.<br><img src="/images/cap-theorem-and-pacelc/pacelc.png" alt="PACELC"></p>
<p>y축 위쪽 끝이 지연시간이라고 표기되어서 오해를 사기 쉬운데, 위쪽에 위치할 수록 지연 시간이 길어지는 것이 아니라 짧아지는 것을 의미한다. 정상 상황에서 일관성에 치우친 시스템은 그만큼 지연 시간이 길어진다는 의미이다.<br>PACELC 이론에서는 장애 상황, 정상 상황에서 어떻게 동작하는지에 따라 시스템을 PC/EC, PC/EL, PA/EC, PA/EL로 나눌 수 있다. 강의에서는 잘 알려진 분산 데이터베이스 시스템들을 이 기준에 따라 나눠 본다. MySQL을 예로 들자면, 마스터-슬레이브로 구성된 MySQL 서버는 기본적으로 PA/EL이고, 설정에 따라 PA/EC가 될 수 있다. MySQL은 따로 설정하지 않으면 마스터에 트랜잭션 발생시 비동기적으로 슬레이브에 데이터를 복제(async replication)한다. MySQL에 semisynchronous replication 플러그인을 사용하는 경우에는 PA/EC 시스템이 되는데 이 플러그인은 다음과 같이 동작하기 때문이다.</p>
<ul>
<li>마스터에서 트랜잭션 발생시 반드시 하나의 슬레이브로부터 복제 완료 알림 또는 타임아웃이 발생한다.(EC)</li>
<li>타임아웃이 발생하면 마스터는 비동기 복제(async replication)로 동작한다.(PA)</li>
</ul>
<p>이외에 Zookeeper, Cassandra, Kafka도 같은 기준으로 설명하는데 자세한 내용은 강의 영상에서 확인할 수 있다.</p>
<h1 id="선택의-기준"><a href="#선택의-기준" class="headerlink" title="선택의 기준"></a>선택의 기준</h1><p>실제 시스템 개발에서 중요한 것은 어떤 종류의 시스템을 선택하여 사용할 지 정하는 것이다. PACELC가 대략적인 분류 기준을 제시하기는 하지만 같은 분류에 속하는 솔루션이라고 해서 완전히 똑같지는 않으며, 다양한 스펙트럼 상에 놓인 솔루션들을 비교하여 <strong>비즈니스에 가장 적합한 솔루션</strong> 을 사용해야 한다. 재고 관리 시스템에서는 일관성을 선택하는 것이 적합할 것이고, SNS에서는 가용성을 선택하는 것이 자연스러울 것이다.</p>
<h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><p>PACELC 이론은 일관성, 가용성, 성능, 파티션 허용성의 관점에서 여러 분산 데이터베이스 솔루션들을 평가할 수 있는 통찰을 준다. 이 이론을 통해 개발자들이 기억해야 할 것은 다음과 같이 요약할 수 있을 것 같다.</p>
<ul>
<li>네트워크 파티션 상황에서 일관성과 가용성은 상충한다.</li>
<li>정상 상황에서 일관성과 성능은 상충한다.</li>
<li>따라서 완벽한 솔루션은 없으며, 비즈니스 상황에 가장 적합한 솔루션을 사용해야한다.</li>
</ul>
<p>당연히 이런 기준만으로 솔루션을 선택할 수는 없다. 데이터베이스는 일관성-가용성 외에도 다른 차원의 속성들이 많기 때문이다. 저장하려는 데이터의 생김새에 따라 관계형 데이터베이스가 적합할 수도 있고, 키-밸류 스토리지가 적합할 수도 있다. 그리고 데이터의 양에 따라 대용량 데이터 저장에 적합한 솔루션을 사용할 수도 있고, 인메모리 데이터베이스를 사용할 수도 있다. 하지만 요즘은 아무리 작은 서비스라도 장애 대응을 위해 서버를 이중화한다. 더 많은 요청을 처리하기 위해 클러스터를 구성하는 경우도 심심찮게 볼 수 있다. 그런 점에서 볼 때 PACELC 이론에서 말하는 것들이 솔루션 선택의 기준이 되는 중요한 차원의 하나이고, 분산 시스템이 일반화되는 요즘에는 그 중요성이 더 커진다고 할 수 있겠다.</p>
<h1 id="참고-문서"><a href="#참고-문서" class="headerlink" title="참고 문서"></a>참고 문서</h1><p><a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank" rel="external">CAP 이론(위키피디아)</a><br><a href="https://en.wikipedia.org/wiki/ACID" target="_blank" rel="external">ACID(위키피디아)</a><br><a href="https://www.youtube.com/watch?v=hUd_9FENShA" target="_blank" rel="external">You don’t need CP, you don’t want AP, and you can’t have CA(영상)</a><br><a href="https://speakerdeck.com/sids/cap-theorem-you-dont-need-cp-you-dont-want-ap-and-you-cant-have-ca" target="_blank" rel="external">You don’t need CP, you don’t want AP, and you can’t have CA(슬라이드)</a></p>
<p><script async class="speakerdeck-embed" data-id="41d0231fc29e4f9eac50b99f5edbc422" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><br><a href="https://en.wikipedia.org/wiki/PACELC_theorem" target="_blank" rel="external">PACELC 이론(위키피디아)</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017-05-22/java-generic-and-variance-2/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'jaeyeolshingithubio';
var disqus_identifier = '2017-07-29/cap-theorem-and-pacelc-theorem/';
var disqus_title = 'CAP 이론과 PACELC 이론을 알아보자';
var disqus_url = 'http://yoursite.com/2017-07-29/cap-theorem-and-pacelc-theorem/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//jaeyeolshingithubio.disqus.com/count.js" async></script><div class="copyright"><p>© 2016 - 2017 <a href="http://yoursite.com">Jaeyeol Shin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-72209766-1",'auto');ga('send','pageview');</script></body></html>