<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>어쩌다 프로그래머</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-07-31T01:04:30.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jaeyeol Shin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CAP 이론과 PACELC 이론을 알아보자</title>
    <link href="http://yoursite.com/2017-07-29/cap-theorem-and-pacelc-theorem/"/>
    <id>http://yoursite.com/2017-07-29/cap-theorem-and-pacelc-theorem/</id>
    <published>2017-07-29T11:40:00.000Z</published>
    <updated>2017-07-31T01:04:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>지지난주 3일동안 동미참 훈련을 받았다. 예비군 훈련이 끝나고 남는 저녁 시간에 뭘할까 하다가 ‘언젠가 공부해야지’하고 생각만하던 것들을 공부하기로 하였다. 포부는 컸으나 3일 동안 <a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank" rel="external">CAP 이론</a> 관련 자료만 몇 개 본 게 전부였다. 그마저도 블로그에 정리하는 것을 미루고 미루다 이제야 정리를 한다.<a id="more"></a></p>
<p>이번에 CAP 이론을 공부하면서 가장 많이 참고한 자료는 <a href="https://www.youtube.com/watch?v=hUd_9FENShA" target="_blank" rel="external">CAP Theorem: You don’t need CP, you don’t want AP, and you can’t have CA</a>라는 싯다르타 레디(Siddhartha Reddy)의 영상이다. 영어라 듣기가 조금 어려웠지만 내용 자체는 어렵지 않고, 강의 자료가 내용을 이해하는데 많은 도움이 되었다. 사실 이 글도 영상의 내용을 정리하고 부가 내용을 조금 더한 것에 지나지 않는다. 강의 자료는 <a href="https://speakerdeck.com/sids/cap-theorem-you-dont-need-cp-you-dont-want-ap-and-you-cant-have-ca" target="_blank" rel="external">Speaker Deck</a>에 올라와 있으며 이 글 마지막에 첨부하였다.</p>
<h1 id="CAP-이론"><a href="#CAP-이론" class="headerlink" title="CAP 이론"></a>CAP 이론</h1><p><a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank" rel="external">CAP 이론</a>에서 CAP은 분산 데이터베이스 시스템의 세 가지 속성인 일관성(Consistency), 가용성(Availability), 파티션 허용성(Partition tolerance)을 나타낸다. 각각의 정의는 다음과 같다.</p>
<table>
<thead>
<tr>
<th>속성</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>일관성</strong></td>
<td>모든 요청은 최신 데이터 또는 에러를 응답받는다.</td>
</tr>
<tr>
<td><strong>가용성</strong></td>
<td>모든 요청은 정상 응답을 받는다.</td>
</tr>
<tr>
<td><strong>파티션 허용성</strong></td>
<td>노드간 통신이 실패하는 경우라도 시스템은 정상 동작 한다.</td>
</tr>
</tbody>
</table>
<p>여기서 말하는 일관성은 <a href="https://en.wikipedia.org/wiki/ACID" target="_blank" rel="external">ACID</a>의 일관성과는 다르다. ACID의 일관성은 데이터베이스에서 트랜잭션이 완료되었을 때 기존의 제약(무결성 등)을 위반하지 않아야 함을 의미한다. 만약 트랜잭션이 제약을 위반한다면 그 트랜잭션은 실패해야한다.</p>
<p>CAP 이론에 따르면 <strong>분산 데이터베이스 시스템은 네트워크 파티션이 발생하였을 때 세 가지 속성 중 두 가지만 만족할 수 있다.</strong> 세 가지 속성 중 두 가지를 만족하는 시스템은 CA(Consistency-Availability), CP(Consistency-Partition tolerance), AP(Availability-Partition tolerance) 세 종류로 나눌 수 있다. 하지만 CAP 이론은 네트워크 파티션 상황을 가정하므로 CA 시스템은 있을 수 없다. CA 시스템이 가능하려면 네트워크 파티션이 없어야 하는데 네트워크 파티션이 없으면 CAP 이론 자체가 쓸모 없을 뿐더러, 네트워크 파티션은 어떤 이유에서든 발생할 수 있다. 여기서 말하는 네트워크 파티션(Network Partition)은 물리적인 네트워크의 분할만을 의미하는 것이 아니다. 분산 시스템에서 노드끼리 데이터를 주고 받을 때 타임아웃이 발생하는 모든 경우를 네트워크 파티션으로 볼 수 있다. 타임아웃은 하드웨어의 문제 뿐만 아니라 방화벽 설정 오류, Java의 Garbage Collection 등 다양한 이유로 발생할 수 있다. 이런 이유로 우리는 네트워크 파티션이 없는 분산 시스템을 가정할 수 없으며, CAP 이론은 이러한 상황에서 분산 데이터베이스 시스템이 일관성(CP)과 가용성(AP) 둘 중에 하나만 만족할 수 있음을 설명한다.</p>
<h1 id="CAP-이론의-한계"><a href="#CAP-이론의-한계" class="headerlink" title="CAP 이론의 한계"></a>CAP 이론의 한계</h1><p>CAP 이론은 분산 시스템의 성질을 너무나도 단순명료하게 설명해준다. 하지만 이 단순함때문에 CAP 이론은 한계를 갖는다. CAP 이론에 따르면 분산 시스템은 CP이거나 AP여야 한다. 하지만 실제 시스템은 둘 중에 하나라고 명확히 구분지을 수 없으며, 완벽한 CP시스템이나 완벽한 AP시스템은 사실상 쓸모가 없다. 하나씩 살펴보자.</p>
<ul>
<li><strong>완벽한 CP시스템</strong> - 완벽한 일관성을 갖는 분산 시스템에서는 하나의 트랜잭션이 다른 모든 노드에 복제된 후에 완료될 수 있다. 이는 가용성 뿐만 아니라 성능의 희생을 필요로 한다. 이런 시스템은 하나의 노드라도 문제가 있으면 트랜잭션은 무조건 실패하고, 노드가 늘어날 수록 지연시간은 길어질 것이다.</li>
<li><strong>완벽한 AP시스템</strong> - 완벽한 가용성을 갖는 시스템은 모든 노드가 어떤 상황에서라도 응답할 수 있어야 한다. 하나의 노드가 네트워크 파티션으로 인해 고립되었다고 생각해보자. 이런 상황에서 고립된 노드가 갖고 있는 데이터는 쓸모가 없어지지만(일관성이 깨지므로) 어쨌든 응답한다면 완벽한 가용성을 갖게 된다. 운 나쁘게 이 노드와 연결된 사용자는 문제를 인지하지 못하고 계속해서 요청을 보낼 것이다.</li>
</ul>
<p>따라서 더 나은 CAP 이론의 해석은 <strong>‘일관성과 가용성은 상충 관계에 있지만 둘 중에 반드시 하나만을 선택해야 하는 것은 아니다’</strong> 이다. 완벽한 CP시스템과 완벽한 AP시스템 사이에는 수많은 가능성이 있다. 요구 사항에 따라 ‘다소 강한 일관성-다소 약한 가용성’, ‘다소 약한 일관성-다소 강한 가용성’과 같이 일관성과 가용성의 수준을 선택해야 한다.<br><img src="/images/cap-theorem-and-pacelc/cap.png" alt="일관성-가용성 스펙트럼"></p>
<p>CAP 이론의 또 다른 한계는 파티션이 없는 상황을 설명하지 못한다는 것이다. 파티션이 없는 상황에서도 분산 시스템은 상충하는 특성들이 있고, 장애 상황만큼이나 정상 상황에서 시스템이 어떻게 동작하는지도 중요하다.</p>
<h1 id="PACELC-이론"><a href="#PACELC-이론" class="headerlink" title="PACELC 이론"></a>PACELC 이론</h1><p>CAP 이론의 이러한 단점들을 보완하기 위해 나온 이론이 바로 <a href="https://en.wikipedia.org/wiki/PACELC_theorem" target="_blank" rel="external">PACELC 이론</a>이다. CAP 이론이 네트워크 파티션 상황에서 일관성-가용성 축을 이용하여 시스템의 특성을 설명한다면, PACELC 이론은 거기에 정상 상황이라는 새로운 축을 더한다. PACELC는 P(네트워크 파티션)상황에서 A(가용성)과 C(일관성)의 상충 관계와 E(else, 정상)상황에서 L(지연 시간)과 C(일관성)의 상충 관계를 설명한다.<br><img src="/images/cap-theorem-and-pacelc/pacelc.png" alt="PACELC"></p>
<p>y축 위쪽 끝이 지연시간이라고 표기되어서 오해를 사기 쉬운데, 위쪽에 위치할 수록 지연 시간이 길어지는 것이 아니라 짧아지는 것을 의미한다. 정상 상황에서 일관성에 치우친 시스템은 그만큼 지연 시간이 길어진다는 의미이다.<br>PACELC 이론에서는 장애 상황, 정상 상황에서 어떻게 동작하는지에 따라 시스템을 PC/EC, PC/EL, PA/EC, PA/EL로 나눌 수 있다. 강의에서는 잘 알려진 분산 데이터베이스 시스템들을 이 기준에 따라 나눠 본다. MySQL을 예로 들자면, 마스터-슬레이브로 구성된 MySQL 서버는 기본적으로 PA/EL이고, 설정에 따라 PA/EC가 될 수 있다. MySQL은 따로 설정하지 않으면 마스터에 트랜잭션 발생시 비동기적으로 슬레이브에 데이터를 복제(async replication)한다. MySQL에 semisynchronous replication 플러그인을 사용하는 경우에는 PA/EC 시스템이 되는데 이 플러그인은 다음과 같이 동작하기 때문이다.</p>
<ul>
<li>마스터에서 트랜잭션 발생시 반드시 하나의 슬레이브로부터 복제 완료 알림 또는 타임아웃이 발생한다.(EC)</li>
<li>타임아웃이 발생하면 마스터는 비동기 복제(async replication)로 동작한다.(PA)</li>
</ul>
<p>이외에 Zookeeper, Cassandra, Kafka도 같은 기준으로 설명하는데 자세한 내용은 강의 영상에서 확인할 수 있다.</p>
<h1 id="선택의-기준"><a href="#선택의-기준" class="headerlink" title="선택의 기준"></a>선택의 기준</h1><p>실제 시스템 개발에서 중요한 것은 어떤 종류의 시스템을 선택하여 사용할 지 정하는 것이다. PACELC가 대략적인 분류 기준을 제시하기는 하지만 같은 분류에 속하는 솔루션이라고 해서 완전히 똑같지는 않으며, 다양한 스펙트럼 상에 놓인 솔루션들을 비교하여 <strong>비즈니스에 가장 적합한 솔루션</strong> 을 사용해야 한다. 재고 관리 시스템에서는 일관성을 선택하는 것이 적합할 것이고, SNS에서는 가용성을 선택하는 것이 자연스러울 것이다.</p>
<h1 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h1><p>PACELC 이론은 일관성, 가용성, 성능, 파티션 허용성의 관점에서 여러 분산 데이터베이스 솔루션들을 평가할 수 있는 통찰을 준다. 이 이론을 통해 개발자들이 기억해야 할 것은 다음과 같이 요약할 수 있을 것 같다.</p>
<ul>
<li>네트워크 파티션 상황에서 일관성과 가용성은 상충한다.</li>
<li>정상 상황에서 일관성과 성능은 상충한다.</li>
<li>따라서 완벽한 솔루션은 없으며, 비즈니스 상황에 가장 적합한 솔루션을 사용해야한다.</li>
</ul>
<p>당연히 이런 기준만으로 솔루션을 선택할 수는 없다. 데이터베이스는 일관성-가용성 외에도 다른 차원의 속성들이 많기 때문이다. 저장하려는 데이터의 생김새에 따라 관계형 데이터베이스가 적합할 수도 있고, 키-밸류 스토리지가 적합할 수도 있다. 그리고 데이터의 양에 따라 대용량 데이터 저장에 적합한 솔루션을 사용할 수도 있고, 인메모리 데이터베이스를 사용할 수도 있다. 하지만 요즘은 아무리 작은 서비스라도 장애 대응을 위해 서버를 이중화한다. 더 많은 요청을 처리하기 위해 클러스터를 구성하는 경우도 심심찮게 볼 수 있다. 그런 점에서 볼 때 PACELC 이론에서 말하는 것들이 솔루션 선택의 기준이 되는 중요한 차원의 하나이고, 분산 시스템이 일반화되는 요즘에는 그 중요성이 더 커진다고 할 수 있겠다.</p>
<h1 id="참고-문서"><a href="#참고-문서" class="headerlink" title="참고 문서"></a>참고 문서</h1><p><a href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank" rel="external">CAP 이론(위키피디아)</a><br><a href="https://en.wikipedia.org/wiki/ACID" target="_blank" rel="external">ACID(위키피디아)</a><br><a href="https://www.youtube.com/watch?v=hUd_9FENShA" target="_blank" rel="external">You don’t need CP, you don’t want AP, and you can’t have CA(영상)</a><br><a href="https://speakerdeck.com/sids/cap-theorem-you-dont-need-cp-you-dont-want-ap-and-you-cant-have-ca" target="_blank" rel="external">You don’t need CP, you don’t want AP, and you can’t have CA(슬라이드)</a></p>
<p><script async class="speakerdeck-embed" data-id="41d0231fc29e4f9eac50b99f5edbc422" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script><br><a href="https://en.wikipedia.org/wiki/PACELC_theorem" target="_blank" rel="external">PACELC 이론(위키피디아)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;지지난주 3일동안 동미참 훈련을 받았다. 예비군 훈련이 끝나고 남는 저녁 시간에 뭘할까 하다가 ‘언젠가 공부해야지’하고 생각만하던 것들을 공부하기로 하였다. 포부는 컸으나 3일 동안 &lt;a href=&quot;https://en.wikipedia.org/wiki/CAP_theorem&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CAP 이론&lt;/a&gt; 관련 자료만 몇 개 본 게 전부였다. 그마저도 블로그에 정리하는 것을 미루고 미루다 이제야 정리를 한다.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 제네릭과 가변성(variance) 2편</title>
    <link href="http://yoursite.com/2017-05-22/java-generic-and-variance-2/"/>
    <id>http://yoursite.com/2017-05-22/java-generic-and-variance-2/</id>
    <published>2017-05-22T03:20:00.000Z</published>
    <updated>2017-05-22T02:24:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2017-05-21/java-generic-and-variance-1/">1편</a>을 쓰느라 진을 너무 많이 뺐다. 사실 이 블로그를 쓰는 이유는 공부하고 까먹고 다시 공부하는 게 싫어서인데 쓰다보면 욕심이 생겨서 다른 자료들도 찾아보고, 예제 코드도 스스로 만들어 보게 된다. 이런 노력이 미래의 내가(그리고 우연히 이곳을 들른 여러분들이?!) 정리한 내용을 이해하는 데 도움이 되었으면 좋겠다. 이번 글에서는 <a href="http://www.yes24.com/24/goods/23449538?scode=032&amp;OzSrank=1" target="_blank" rel="external">카이 호스트만의 코어 자바8</a>의 내용과 상관없이 <a href="/2017-05-21/java-generic-and-variance-1/">1편</a>에서 다뤘던 가변성에 대한 내용을 조금만 더 정리하려 한다.<a id="more"></a></p>
<h1 id="리스코프-치환-원칙-Liskov-Substitution-Principle"><a href="#리스코프-치환-원칙-Liskov-Substitution-Principle" class="headerlink" title="리스코프 치환 원칙(Liskov Substitution Principle)"></a>리스코프 치환 원칙(Liskov Substitution Principle)</h1><p>객체 지향 프로그래밍을 공부해본 사람들이라면 한번쯤은 들어봤을 법한 원칙이다. 줄여서 LSP라고도 하는 이 원칙은 수학적인 내용을 담고 있을 것 같아 압도되는 느낌을 주지만, 사실 OOP에서는 아주 친숙한 개념이다. <a href="https://ko.wikipedia.org/wiki/%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84_%EC%B9%98%ED%99%98_%EC%9B%90%EC%B9%99" target="_blank" rel="external">위키피디아</a>에는 이 원칙을 이렇게 설명하고 있다.</p>
<blockquote>
<p>컴퓨터 프로그램에서 자료형 <strong><em>S</em></strong> 가 자료형 <strong><em>T</em></strong> 의 하위형이라면 필요한 프로그램의 속성(정확성, 수행하는 업무 등)의 변경 없이 자료형 <strong><em>T</em></strong> 의 객체를 자료형 <strong><em>S</em></strong> 의 객체로 교체(치환)할 수 있어야 한다.</p>
</blockquote>
<p>흔히 알고 있는 상속, 다형성의 개념과 일치한다. 하지만 상속을 사용한다고 해서 무조건 LSP를 지키는 것은 아니다. <a href="https://ko.wikipedia.org/wiki/%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84_%EC%B9%98%ED%99%98_%EC%9B%90%EC%B9%99" target="_blank" rel="external">위키피디아</a>를 보면 LSP를 위반하여 상속을 하는 사례가 나오는데 한 번 읽어보면 좋다.</p>
<p>자바 가변성 얘기를 하다말고 갑자기 LSP 얘기를 꺼내서 조금 의아하게 느껴질 수도 있겠다. 하지만 가변성을 공부할 때 이 원칙에 입각하여 생각해보면 이해하기가 쉬워진다. 나는 가변성의 개념을 스칼라를 공부할 때 처음 접하게 되었는데, 당시에 반공변성을 이해하는 것이 너무나도 힘들었다. 오늘 겨우겨우 이해를 해도 다음 날이 되면 또 납득이 되질 않아서 고민하는 식이었다. 여기서 다시 반공변성의 의미를 떠올려보자.</p>
<blockquote>
<p>T’가 T의 서브타입이면, C&lt;T&gt;는 C&lt;T’&gt;의 서브타입이다.</p>
</blockquote>
<p>타입 파라미터와 반대 방향으로 클래스 계층이 결정된다는 것이 이해하기 어렵다. 트위터의 스칼라 문서인 <a href="https://twitter.github.io/scala_school/ko/type-basics.html" target="_blank" rel="external">타입과 다형성의 기초</a>에서는 <code>Animal</code>, <code>Bird</code>, <code>Chicken</code>, <code>Duck</code> 같은 임의의 클래스 계층을 도입하여 ‘오리는 닭짓(?)을 할 수 없기 때문에 메서드 파라미터는 반공변적이다’ 라고 친절하게 설명하지만 머리 속에 클래스들이 둥둥 떠다닐 뿐 잘 와닿지 않았다. 하지만 리스코프 치환 원칙에서 서브타입의 의미를 생각해보면 쉽게 이해할 수 있다. 자바의 <code>Predicate&lt;T&gt;</code>를 예로 들어보자. <a href="/2017-05-21/java-generic-and-variance-1/">1편</a>에서 설명했다시피 <code>Predicate&lt;T&gt;</code>는 타입 <code>T</code>가 메서드의 파라미터가 되는 함수형 인터페이스이므로 반공변적이다. <code>CharSequence</code>에 대해 테스트할 수 있는 함수를 저장하고 싶다면 다음과 같이 변수를 선언해야 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Predicate&lt;? <span class="keyword">super</span> CharSequence&gt; pred;</div></pre></td></tr></table></figure>
<p>그리고 <code>pred</code> 변수에 저장할 수 있는 다음 세 가지 후보를 생각해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Predicate&lt;CharSequence&gt; predCs = cs -&gt; cs.charAt(<span class="number">0</span>) == <span class="string">'a'</span>;</div><div class="line">Predicate&lt;String&gt; predStr = str -&gt; <span class="string">"ABC"</span>.equals(str.toUpperCase());</div><div class="line">Predicate&lt;Object&gt; predObj = obj -&gt; obj != <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
<p>우리가 기대하는 <code>pred</code> 변수의 속성은 무엇인가? <strong><code>CharSequence</code> 타입의 인자를 넘겨 호출하는 것</strong>이다. <code>Predicate&lt;? super CharSequence&gt;</code>의 서브타입이라면 이 속성을 유지해야 한다. 그러면 누가 <code>pred</code> 변수에 들어갈 수 있고 없는지가 명확히 구분된다.</p>
<table>
<thead>
<tr>
<th>후보</th>
<th style="text-align:center"><code>CharSequence</code> 타입의 인자로 호출할 수 있는가?</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Predicate&lt;CharSequence&gt; predCs</code></td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td><code>Predicate&lt;String&gt; predStr</code></td>
<td style="text-align:center">X</td>
</tr>
<tr>
<td><code>Predicate&lt;Object&gt; predObj</code></td>
<td style="text-align:center">O</td>
</tr>
</tbody>
</table>
<h1 id="사용처-가변성-use-site-variance-과-선언처-가변성-declaration-site-variance"><a href="#사용처-가변성-use-site-variance-과-선언처-가변성-declaration-site-variance" class="headerlink" title="사용처 가변성(use-site variance)과 선언처 가변성(declaration-site variance)"></a>사용처 가변성(use-site variance)과 선언처 가변성(declaration-site variance)</h1><p>자바는 제네릭 클래스를 사용하는 쪽에서 와일드카드로 가변성을 결정하기 때문에 자바의 가변성을 <strong>사용처 가변성</strong>이라고 한다. 이는 개발자를 조금 귀찮게 하는데 매번 변수나 파라미터의 타입을 선언할 때마다 공변적 혹은 반공변적이어야 하는지 고민해야 하고, 타입 파라미터에는 타입 뿐만 아니라 <code>&lt;? extends T&gt;</code>, <code>&lt;? super T&gt;</code>와 같이 와일드카드와 경계를 함께 적어줘야 하기 때문이다. 하지만 어떤 제네릭 클래스든 개발자가 자기가 사용하고 싶은대로 가변성을 결정할 수 있다는 장점도 갖고 있다. 예를 들어 <code>List&lt;T&gt;</code>는 본래 요소의 조회 및 추가가 모두 가능한 클래스이지만 타입을 <code>List&lt;? extends String&gt;</code>로 지정하면 읽기 전용 리스트로 사용할 수 있다. 아무짝에도 쓸모가 없겠지만 <code>Predicate&lt;? extends CharSequence&gt;</code>와 같은 타입도 선언이 가능하다.</p>
<p>사용처 가변성과 대응되는 개념이 바로 <strong>선언처 가변성</strong>이다. 여기서 선언처는 타입이 선언되는 곳을 의미한다. 스칼라는 대표적인 선언처 가변성 언어이다. 파라미터를 하나만 받는 함수를 나타내는 <code>Function1</code> 트레이트(자바의 인터페이스와 유사)를 살펴보자.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[-<span class="type">T1</span>, +<span class="type">R</span>] <span class="keyword">extends</span> <span class="title">AnyRef</span></span></div></pre></td></tr></table></figure>
<p><code>AnyRef</code>는 자바의 <code>Object</code>와 동일하다. <code>T1</code>, <code>R</code>은 각각 파라미터와 리턴 값에 해당하는 타입 파라미터이다. 그런데 앞에 <code>-</code>, <code>+</code>가 붙어있다. 스칼라에서는 타입 파라미터 앞에 <code>-</code>를 붙여 반공변성, <code>+</code>를 붙여 공변성을 나타낸다. 이처럼 스칼라에서는 타입 선언부에 가변성이 정해져있기 때문에 사용하는 입장에서는 편리하다. 앞서 봤던 <code>Predicate&lt;T&gt;</code> 예제를 스칼라 버전으로 바꾸어 보자.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pred: <span class="type">Function1</span>[<span class="type">CharSequence</span>, <span class="type">Boolean</span>]</div><div class="line"><span class="keyword">val</span> predCs: <span class="type">Function1</span>[<span class="type">CharSequence</span>, <span class="type">Boolean</span>] = cs =&gt; cs.charAt(<span class="number">0</span>) == 'a'</div><div class="line"><span class="keyword">val</span> predStr: <span class="type">Function1</span>[<span class="type">String</span>, <span class="type">Boolean</span>] = str =&gt; <span class="string">"ABC"</span> == str.toUpperCase</div><div class="line"><span class="keyword">val</span> predObj: <span class="type">Function1</span>[<span class="type">AnyRef</span>, <span class="type">Boolean</span>] = ref =&gt; ref != <span class="literal">null</span></div><div class="line"></div><div class="line">pred = predCs</div><div class="line">pred = predStr <span class="comment">// 컴파일 에러</span></div><div class="line">pred = predObj</div></pre></td></tr></table></figure>
<p>스칼라는 <code>Function1</code> 정의에서 가변성이 함께 정의되어 있기 때문에 개발자가 가변성에 대한 고민을 하지 않아도 되고, 번거롭게 <code>? extends</code>, <code>? super</code>를 쓰지 않아도 된다. 대신 스칼라는 라이브러리 개발자들이 조금 더 고생한다. 스칼라 컬렉션 라이브러리는 <code>scala.collection.mutable</code> 패키지와 <code>scala.collection.immutable</code> 패키지로 나뉜다. <code>mutable</code> 컬렉션은 조회와 수정 모두 가능하기 때문에 무공변적이지만 <code>immutable</code> 컬렉션은 읽기 전용이므로 공변적이다.</p>
<h1 id="참고-문서"><a href="#참고-문서" class="headerlink" title="참고 문서"></a>참고 문서</h1><p><a href="/2017-05-21/java-generic-and-variance-1/">Covariance and contravariance - 위키피디아</a><br><a href="http://www.yes24.com/24/goods/23449538?scode=032&amp;OzSrank=1" target="_blank" rel="external">카이 호스트만의 코어 자바8</a><br><a href="https://ko.wikipedia.org/wiki/%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84_%EC%B9%98%ED%99%98_%EC%9B%90%EC%B9%99" target="_blank" rel="external">리스코프의 치환 원칙</a><br><a href="https://twitter.github.io/scala_school/ko/type-basics.html" target="_blank" rel="external">타입과 다형성의 기초 - twitter.github.io</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2017-05-21/java-generic-and-variance-1/&quot;&gt;1편&lt;/a&gt;을 쓰느라 진을 너무 많이 뺐다. 사실 이 블로그를 쓰는 이유는 공부하고 까먹고 다시 공부하는 게 싫어서인데 쓰다보면 욕심이 생겨서 다른 자료들도 찾아보고, 예제 코드도 스스로 만들어 보게 된다. 이런 노력이 미래의 내가(그리고 우연히 이곳을 들른 여러분들이?!) 정리한 내용을 이해하는 데 도움이 되었으면 좋겠다. 이번 글에서는 &lt;a href=&quot;http://www.yes24.com/24/goods/23449538?scode=032&amp;amp;OzSrank=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;카이 호스트만의 코어 자바8&lt;/a&gt;의 내용과 상관없이 &lt;a href=&quot;/2017-05-21/java-generic-and-variance-1/&quot;&gt;1편&lt;/a&gt;에서 다뤘던 가변성에 대한 내용을 조금만 더 정리하려 한다.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 제네릭과 가변성(variance) 1편</title>
    <link href="http://yoursite.com/2017-05-21/java-generic-and-variance-1/"/>
    <id>http://yoursite.com/2017-05-21/java-generic-and-variance-1/</id>
    <published>2017-05-20T16:30:00.000Z</published>
    <updated>2017-05-22T02:24:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.yes24.com/24/goods/23449538?scode=032&amp;OzSrank=1" target="_blank" rel="external">카이 호스트만의 코어 자바8</a> 책으로 공부를 계속하고 있다. 게으른 탓인지 진도가 정말 느리다. 간만에 배운 내용을 정리하고자 했는데 직전에 쓴 글이 한 달 전이라니… 너무 부끄럽다. 가끔 yes24에서 서평들을 보면 일주일 만에 기술 책 한권을 독파하고 소감을 쓰시는 분들도 계신데, 이런 분들을 보면 부럽기도 하고 존경스럽다. 여하튼 이번 주제는 Java의 제네릭과 가변성(variance)이다. 제네릭을 자주 사용하면서도 자바 제네릭의 타입 경계, 와일드 카드, 타입 소거 같은 특징들에 대해서는 잘 알지 못했다. 가변성은 볼 때마다 헷갈리는 개념이다. 이번 포스팅을 통해 이런 개념들을 정리해보려고 한다.<a id="more"></a></p>
<h1 id="제네릭-클래스"><a href="#제네릭-클래스" class="headerlink" title="제네릭 클래스"></a>제네릭 클래스</h1><p>제네릭 클래스는 타입 파라미터를 한 개 이상 받는 클래스이다. 타입을 파라미터로 받는다는 것은 클래스 선언시에는 타입을 특정하지 않고 인스턴스 생성시에 사용할 타입을 정하는 것을 의미한다. 보통 제네릭은 컬렉션 클래스와 많이 사용된다. 컬렉션 중 타입 파라미터를 하나만 받는 대표적인 인터페이스로는 <code>java.util.List</code>가 있고, 두 개 받는 것으로는 <code>java.util.Map</code>이 있다. 리스트는 저장되는 요소의 타입을 위해 타입 파라미터를 하나만 받는다. 맵은 키-값의 컬렉션으로 키의 타입, 값의 타입 두 개의 타입 파라미터를 받는다. 타입 파라미터는 인스턴스 변수, 메서드의 파라미터 및 반환 타입으로 사용된다. 자바 개발자들은 제네릭을 사용해서 보다 편리하고 안전하게 프로그래밍을 할 수 있다. 아래는 흔히 볼 수 있는 제네릭을 이용한 코드이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; cities = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">cities.add(<span class="string">"Changwon"</span>);</div><div class="line">cities.add(<span class="string">"Seoul"</span>);</div><div class="line">cities.add(<span class="string">"Suwon"</span>);</div><div class="line">cities.add(<span class="string">"Yongin"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (String city : cities) &#123;</div><div class="line">    System.out.println(city.toUpperCase());</div><div class="line">&#125;</div><div class="line"><span class="comment">// 결과:</span></div><div class="line"><span class="comment">// CHANGWON</span></div><div class="line"><span class="comment">// SEOUL</span></div><div class="line"><span class="comment">// SUWON</span></div><div class="line"><span class="comment">// YONGIN</span></div></pre></td></tr></table></figure>
<p>제네릭은 자바의 타입을 확장하기 때문에 잘못된 입력을 컴파일 타임에 잡아준다. 즉, 프로그래머가 <code>List&lt;String&gt;</code>라고 자료형을 선언했다면 이 리스트에는 문자열만 저장하고, 조회할 수 있다는 확신을 가질 수 있다. 위 코드 예제에서 <code>cities.add(1);</code>과 같은 코드는 컴파일 에러를 발생시킨다. 그 이유는 <code>List</code> 인터페이스에 <code>add()</code> 메서드가 아래와 같이 제네릭 타입으로 정의되어 있고, <code>List&lt;String&gt;</code>은 타입 파라미터 <code>E</code>를 <code>String</code>으로 치환하기 때문이다. 따라서 <code>List&lt;String&gt;</code>의 <code>add()</code>는 문자열을 입력받는 메서드가 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; <span class="comment">// List&lt;String&gt;에서는 boolean add(String e); 가 된다.</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>cities</code>를 향상된 for loop으로 각 문자열 요소를 순회할 수 있는 것도 같은 원리이다. <code>List&lt;E&gt;</code>는 <code>Collection&lt;E&gt;</code>를 <code>Collection&lt;E&gt;</code>는 <code>Iterable&lt;E&gt;</code>를 상속받는다. 이 상속 관계는 타입 파라미터와 상관없이 유지된다. 결국 <code>List&lt;String&gt;</code>은 <code>Iterable&lt;String&gt;</code>이기 때문에 개별 문자열을 향상된 for loop으로 순회할 수 있는 것이다. 자바의 제네릭은 2002년 Java 5 발표와 함께 등장했는데 그 이전에는 컬렉션을 다루는 것이 무척이나 불편했다고 한다.(물론 나는 그 시절의 자바를 겪어보지 않았다.) 제네릭이 없었기 때문에 요소의 타입은 최상위 클래스인 <code>Object</code>였다. Iterator는 Java 5 이전에도 있었지만 향상된 for loop은 Java 5에서 소개되었다. 아마도 그 시절의 리스트 순회는 다음과 같지 않았을까?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List cities = <span class="keyword">new</span> ArrayList();</div><div class="line"><span class="comment">// (요소를 삽입한다.)</span></div><div class="line"><span class="keyword">for</span> (Iterator iter = cities.iterator(); iter.hasNext(); ) &#123;</div><div class="line">    String city = (String) iter.next();</div><div class="line">    System.out.println(city.toUpperCase());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="제네릭-메서드"><a href="#제네릭-메서드" class="headerlink" title="제네릭 메서드"></a>제네릭 메서드</h1><p>제네릭 메서드는 타입 파라미터를 받는 메서드이다. 제네릭 메서드는 일반 클래스나 제네릭 클래스의 메서드가 될 수 있다. 다음 제네릭 메서드는 리스트의 처음 세 요소만 갖는 새로운 리스트를 반환한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">firstThree</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> list.stream().limit(<span class="number">3</span>).collect(Collectors.toList());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 메서드를 앞선 예제 코드에 응용해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; cities = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">cities.add(<span class="string">"Changwon"</span>);</div><div class="line">cities.add(<span class="string">"Seoul"</span>);</div><div class="line">cities.add(<span class="string">"Suwon"</span>);</div><div class="line">cities.add(<span class="string">"Yongin"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (String city : firstThree(cities)) &#123;</div><div class="line">    System.out.println(city.toUpperCase());</div><div class="line">&#125;</div><div class="line"><span class="comment">// 결과:</span></div><div class="line"><span class="comment">// CHANGWON</span></div><div class="line"><span class="comment">// SEOUL</span></div><div class="line"><span class="comment">// SUWON</span></div></pre></td></tr></table></figure>
<p>향상된 for loop 안에서 제네릭 메서드 <code>firstThree()</code>를 호출하였다. 제네릭 메서드를 호출할 때는 타입 파라미터를 명시하지 않아도 컴파일러가 자동으로 타입을 유추한다. 타입 파라미터 <code>T</code>는 자동으로 <code>String</code>으로 치환되고, 메서드는 <code>List&lt;String&gt;</code>을 반환한다.</p>
<h1 id="타입-경계"><a href="#타입-경계" class="headerlink" title="타입 경계"></a>타입 경계</h1><p>제네릭 클래스나 메서드가 받는 타입 파라미터를 제한하고 싶은 경우에 타입 경계를 사용할 수 있다. <code>firstThree()</code>는 전달 받은 타입 파라미터에 구애 받지 않는 메서드이기 때문에 타입을 제한하지 않았다. 하지만 특정 타입의 메서드나 필드를 이용해야 하는 경우라면 그에 맞는 경계를 선언해야 한다. 다음 메서드는 문자열의 리스트를 입력받아 각 문자열의 첫 번째 글자로 이루어진 리스트를 반환한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends CharSequence&gt; <span class="function">List&lt;Character&gt; <span class="title">firstChars</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> list.stream().map(cs -&gt; cs.charAt(<span class="number">0</span>)).collect(Collectors.toList());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>타입 파라미터 <code>&lt;T extedns CharSequence&gt;</code>는 타입 파라미터 <code>T</code>를 <code>CharSequence</code>의 서브타입으로 제한한다. 따라서 <code>firstChars()</code>를 호출할 때는 <code>CharSequence</code> 혹은 그 서브타입의 리스트를 인자로 전달해야 한다. 이제 <code>T</code>가 <code>CharSequence</code>인 것을 알았으므로 리스트 각 요소에 대해 <code>CharSequence</code>의 메서드를 호출할 수 있다. 예제에서는 <code>charAt(0)</code>을 호출하여 첫 번째 문자를 반환하도록 하였다. 타입 파라미터에 경계를 설정하지 않는 것은 최상위 클래스인 <code>Object</code>를 경계로 설정하는 것과 동일하다.</p>
<h1 id="타입-가변성-variance-과-와일드-카드"><a href="#타입-가변성-variance-과-와일드-카드" class="headerlink" title="타입 가변성(variance)과 와일드 카드"></a>타입 가변성(variance)과 와일드 카드</h1><p><img src="/images/Java_wildcard_subtyping.svg" alt="자바의 와일드카드 서브타이핑"></p>
<p style="text-align:center;color:#808080;">자바의 와일드카드와 클래스 계층(이미지 출처: <a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)#Use-site_variance_annotations_.28wildcards.29" target="_blank" rel="external">위키백과</a>)</p>

<h2 id="가변성이란"><a href="#가변성이란" class="headerlink" title="가변성이란?"></a>가변성이란?</h2><p>가변성은 타입 파라미터가 클래스 계층에 어떤 영향을 미치는지를 나타낸다. 다음 가변성 표를 보자.</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>의미</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>공변성(covariant)</strong></td>
<td>T’가 T의 서브타입이면, C&lt;T’&gt;는 C&lt;T&gt;의 서브타입이다.</td>
</tr>
<tr>
<td><strong>반공변성(contravariant)</strong></td>
<td>T’가 T의 서브타입이면, C&lt;T&gt;는 C&lt;T’&gt;의 서브타입이다.</td>
</tr>
<tr>
<td><strong>무변성(invariant)</strong></td>
<td>C&lt;T&gt;와 C&lt;T’&gt;는 아무 관계가 없다.</td>
</tr>
</tbody>
</table>
<p>자바의 제네릭은 기본적으로 무변성이다. <code>String</code>은 <code>CharSequence</code>의 서브타입이지만, <code>List&lt;String&gt;</code>과 <code>List&lt;CharSequence&gt;</code>는 아무 관계가 없다. <code>List&lt;CharSequence&gt; list = new ArrayList&lt;String&gt;();</code> 같은 코드는 컴파일 에러를 발생한다. 그렇기 때문에 위 표에서 공변성, 반공변성을 설명한 것은 틀린 표현이다. 표는 <a href="https://twitter.github.io/scala_school/ko/type-basics.html" target="_blank" rel="external">타입과 다형성의 기초</a>에서 설명한 스칼라의 가변성 표를 그대로 가져와 꺽쇠 모양만 자바에 맞게 바꾼 것이다. 그럼에도 위와 같이 표기한 이유는 개념적으로 이해 하기가 더 쉽기 때문이다. 실제로 자바 제네릭에서는 와일드카드를 사용해야만 가변성을 지정할 수 있다. 와일드카드를 설명한 후에 실제 자바 표현에 맞게 위 표를 수정해 볼 것이다.</p>
<h2 id="와일드카드"><a href="#와일드카드" class="headerlink" title="와일드카드"></a>와일드카드</h2><p>와일드 카드를 이해하기 위해 다음 두 메서드를 보자. 어느 것이 더 유용한 메서드일까?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection collection)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Object e : collection) &#123;</div><div class="line">        System.out.println(e);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollectionGen</span><span class="params">(Collection&lt;Object&gt; collection)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Object e : collection) &#123;</div><div class="line">        System.out.println(e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>printCollectionGen()</code>이 제네릭도 사용하고 뭔가 있어 보이지만 이 메서드는 별로 쓸모가 없다. 앞서 말했듯이 자바 제네릭은 기본적으로 무변성이기 때문이다. <code>Object</code>가 최상위 클래스이긴 하지만 <code>Collection&lt;Object&gt;</code>는 <code>Collection&lt;String&gt;</code>, <code>List&lt;String&gt;</code>과는 아무 관계가 없다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; cities = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">cities.add(<span class="string">"Changwon"</span>);</div><div class="line">cities.add(<span class="string">"Seoul"</span>);</div><div class="line">cities.add(<span class="string">"Suwon"</span>);</div><div class="line">cities.add(<span class="string">"Yongin"</span>);</div><div class="line"></div><div class="line">printCollection(cities); <span class="comment">// List&lt;String&gt;은 Collection의 서브타입이다.</span></div><div class="line"><span class="comment">// 결과:</span></div><div class="line"><span class="comment">// Changwon</span></div><div class="line"><span class="comment">// Seoul</span></div><div class="line"><span class="comment">// Suwon</span></div><div class="line"><span class="comment">// Yongin</span></div><div class="line">printCollectionGen(cities); <span class="comment">// List&lt;String&gt;은 Collection&lt;Object&gt;와 아무 관계가 없다.</span></div><div class="line"><span class="comment">// 컴파일 에러</span></div></pre></td></tr></table></figure>
<p><code>printCollectionGen()</code>을 쓸모있게 만드려면 타입 파라미터에 <code>Object</code> 대신 와일드카드 <code>?</code>를 사용해야 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollectionGen</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Object e : collection) &#123;</div><div class="line">        System.out.println(e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이렇게 하면 위에서 컴파일 에러가 나던 코드도 정상적으로 동작한다. 와일드카드 <code>?</code>는 <em>Unknown</em> 타입으로 어떤 타입이든 올 수 있다. <code>?</code>가 무엇인지는 모르겠지만 <code>Object</code>인 것은 확실하기 때문에 <code>Object</code> 타입으로 요소를 순회할 수 있다.</p>
<h2 id="서브타입-와일드카드"><a href="#서브타입-와일드카드" class="headerlink" title="서브타입 와일드카드"></a>서브타입 와일드카드</h2><p>타입 파라미터에서 그랬던 것 처럼 와일드카드에도 타입 경계를 설정할 수 있다. 와일드카드를 사용하면 <code>firstChars()</code> 메서드를 좀 더 간단하게 작성할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Character&gt; <span class="title">firstChars</span><span class="params">(List&lt;? extends CharSequence&gt; list)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> list.stream().map(cs -&gt; cs.charAt(<span class="number">0</span>)).collect(Collectors.toList());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>자바는 서브타입 와일드카드를 이용하여 <strong>공변성</strong>을 표현한다. 이 메서드는 <code>CharSequence</code>의 서브타입으로 이루어진 리스트 객체라면 무엇이든지 받을 수 있다(예를 들면 <code>ArrayList&lt;String&gt;</code>). 서브타입 와일드카드는 메서드의 반환 타입에서는 사용할 수 있지만, 메서드의 파라미터에는 사용할 수 없다. 다음 코드를 보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;? extends String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">String first = list.get(<span class="number">0</span>); <span class="comment">// 반환 타입을 String 변수에 저장할 수 있다.</span></div><div class="line">list.add(<span class="string">"abc"</span>); <span class="comment">// 컴파일 에러. String 변수를 인자로 넘길 수 없다.</span></div></pre></td></tr></table></figure>
<p><code>list</code>의 타입 파라미터는 <code>? extends String</code> 이다. IntelliJ에서 <code>list.get()</code>이 반환하는 타입을 보면 <code>capture of ? extends String</code>라고 나타난다. 뭔지는 모르겠지만 <code>String</code>의 서브타입이라는 것이다. 그렇기 때문에 <code>get()</code>의 반환 값을 <code>String</code> 변수에 저장할 수 있다. 하지만 <code>add()</code>는 사용할 수 없다. <code>add()</code>를 호출하려면 <code>capture of ? extends String</code>나 그 서브타입 변수를 넘겨야 하지만 뭔지도 모르는 타입의 변수를 만들 방법이 없다. <code>&quot;abc&quot;</code>는 <code>capture of ? extends String</code>이 아니기 때문에 컴파일 에러가 발생하는 것이다.</p>
<h2 id="슈퍼타입-와일드카드"><a href="#슈퍼타입-와일드카드" class="headerlink" title="슈퍼타입 와일드카드"></a>슈퍼타입 와일드카드</h2><p>서브타입 와일드카드가 공변성을 나타낸다면 슈퍼타입 와일드카드는 <strong>반공변성</strong>을 나타낸다. 반공변성의 의미를 다시 살펴 보자.</p>
<blockquote>
<p>T’가 T의 서브타입이면, C&lt;T&gt;는 C&lt;T’&gt;의 서브타입이다.</p>
</blockquote>
<p>타입 파라미터와 계층 관계가 반대로 움직인다니 뭔가 이상하다. 그리고 이런게 어디에 쓰인단 말인가. 앞서 서브타입 와일드카드는 메서드의 반환 값에는 사용될 수 있지만 파라미터 타입에서는 사용될 수 없다고 했다. 슈퍼타입 와일드카드는 메서드의 파라미터 타입을 설정할 때 사용된다. 하지만 반대로 메서드의 반환 값으로는 사용할 수 없다. 앞선 예제의 <code>? extends String</code>을 <code>? super String</code>으로 바꾸고 무슨 일이 일어나는지 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;? <span class="keyword">super</span> String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">String first = list.get(<span class="number">0</span>); <span class="comment">// 컴파일 에러. 반환 타입을 String 변수에 저장할 수 없다.</span></div><div class="line">list.add(<span class="string">"abc"</span>); <span class="comment">// String 변수를 인자로 넘길 수 있다.</span></div></pre></td></tr></table></figure>
<p>신기하게도 컴파일 에러가 나는 코드가 뒤바뀌었다. 서브타입 와일드카드에서 했던 것처럼 왜그런지 한번 살펴보자. 이제 <code>list</code>의 타입 파라미터는 <code>? super String</code>이 되었다. <code>get()</code>이 반환하는 타입은 뭔지 모르겠지만 <code>String</code>의 슈퍼타입이기 때문에 <code>String</code> 타입의 변수에 저장할 수 없다. 이는 <code>String</code> 변수에 <code>new Object()</code>를 할당할 수 없는 것과 같은 이치다. 반대로 <code>? super String</code>가 뭔지는 모르지만 <code>String</code>의 슈퍼타입인 것은 확실하므로 <code>String</code> 변수를 <code>add()</code> 호출에 사용할 수 있는 것이다. 이를 통해 <strong>메서드의 반환 타입은 공변적이고, 메서드의 파라미터 타입은 반공변적</strong> 이라는 것을 알 수 있다.</p>
<p>이런 이유로 슈퍼타입 와일드카드는 주로 인자 타입이 타입 파라미터로 결정되는 함수형 인터페이스에서 사용된다. 전형적인 예로 함수형 인터페이스 <code>Predicate&lt;T&gt;</code>가 있다. <code>Predicate&lt;T&gt;</code>는 <code>T</code> 타입의 변수를 입력받아 불리언 값을 반환한다. 다음 예제를 보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"가"</span>, <span class="keyword">null</span>, <span class="string">"나"</span>, <span class="keyword">null</span>, <span class="string">"다"</span>);</div><div class="line">Predicate&lt;Object&gt; notnull = (obj) -&gt; obj != <span class="keyword">null</span>;</div><div class="line">stream.filter(notnull).forEach(System.out::print);</div><div class="line"><span class="comment">// 결과:</span></div><div class="line"><span class="comment">// 가나다</span></div></pre></td></tr></table></figure>
<p><code>Stream&lt;String&gt;.filter()</code>는 <code>Predicate&lt;? super String&gt;</code>을 인자로 받는다. 인자로 받은 함수를 이용하여 문자열을 테스트하고 테스트를 통과한 문자열로만 구성된 스트림을 반환한다. <code>Predicate&lt;Object&gt;</code>는 <code>Predicate&lt;? super String&gt;</code>의 서브타입이기 때문에 <code>notnull</code>을 인자로 넘겨줄 수 있는 것이다.</p>
<p>자, 이제 위에서 약속한대로 가변성 표를 자바 표기법에 맞게 바꾸어보자.</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>의미</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>공변성(covariant)</strong></td>
<td>T’가 T의 서브타입이면, C&lt;T’&gt;는 C&lt;? extends T&gt;의 서브타입이다.</td>
</tr>
<tr>
<td><strong>반공변성(contravariant)</strong></td>
<td>T’가 T의 서브타입이면, C&lt;T&gt;는 C&lt;? super T’&gt;의 서브타입이다.</td>
</tr>
<tr>
<td><strong>무공변성(invariant)</strong></td>
<td>C&lt;T&gt;와 C&lt;T’&gt;는 아무 관계가 없다.</td>
</tr>
</tbody>
</table>
<h1 id="참고-문서"><a href="#참고-문서" class="headerlink" title="참고 문서"></a>참고 문서</h1><p><a href="http://www.yes24.com/24/goods/23449538?scode=032&amp;OzSrank=1" target="_blank" rel="external">카이 호스트만의 코어 자바8</a><br><a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)#Use-site_variance_annotations_.28wildcards.29" target="_blank" rel="external">Covariance and contravariance - 위키피디아</a><br><a href="https://twitter.github.io/scala_school/ko/type-basics.html" target="_blank" rel="external">타입과 다형성의 기초 - twitter.github.io</a><br><a href="https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html" target="_blank" rel="external">wildcards - 오라클</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.yes24.com/24/goods/23449538?scode=032&amp;amp;OzSrank=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;카이 호스트만의 코어 자바8&lt;/a&gt; 책으로 공부를 계속하고 있다. 게으른 탓인지 진도가 정말 느리다. 간만에 배운 내용을 정리하고자 했는데 직전에 쓴 글이 한 달 전이라니… 너무 부끄럽다. 가끔 yes24에서 서평들을 보면 일주일 만에 기술 책 한권을 독파하고 소감을 쓰시는 분들도 계신데, 이런 분들을 보면 부럽기도 하고 존경스럽다. 여하튼 이번 주제는 Java의 제네릭과 가변성(variance)이다. 제네릭을 자주 사용하면서도 자바 제네릭의 타입 경계, 와일드 카드, 타입 소거 같은 특징들에 대해서는 잘 알지 못했다. 가변성은 볼 때마다 헷갈리는 개념이다. 이번 포스팅을 통해 이런 개념들을 정리해보려고 한다.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 8 - Interface의 변화</title>
    <link href="http://yoursite.com/2017-04-19/java8-changes-in-interface/"/>
    <id>http://yoursite.com/2017-04-19/java8-changes-in-interface/</id>
    <published>2017-04-19T07:32:00.000Z</published>
    <updated>2017-04-20T02:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>요즘 <a href="http://www.yes24.com/24/goods/23449538?scode=032&amp;OzSrank=1" target="_blank" rel="external">카이 호스트만의 코어 자바8</a>로 Java 8을 공부하고 있다. 작년 초에 개발자로 전향하여 Java 8의 stream 같은 것을 <del>매우 신기해하며</del> 어깨너머로 배워 사용했었는데 알고보니 Java 8이 처음 출시된 것은 2014년 3월 18일이었다.(<a href="https://www.java.com/ko/download/faq/release_dates.xml" target="_blank" rel="external">Java 릴리스 페이지 참고</a>) 지금은 Java 9가 나오려고 몸을 들썩이는 중이다. Java 8을 제대로 공부도 해보지 않았는데 벌써 Java 9가 나온다고 하니 젊은 나이에 뒤처지는 것 같은 기분이 들었다. 이런 까닭에 황급히 서점에서 책을 사서 공부하는 중이다. 원저의 제목 <a href="https://www.amazon.com/Core-Java-Impatient-Cay-Horstmann/dp/0321996321" target="_blank" rel="external">Core Java for the Impatient</a>가 내 상황에 잘 들어맞는 것 같다. 오랜만에 블로그에 글도 올릴 겸 더 늦기 전에 Java 8을 공부하면서 중요하다고 생각하는 것들을 정리해보려고 한다.<a id="more"></a></p>
<h1 id="인터페이스"><a href="#인터페이스" class="headerlink" title="인터페이스"></a>인터페이스</h1><p>객체 지향 프로그래밍에서 인터페이스는 기능의 생김새만 나타낸다. 인터페이스는 어떤 기능에 대한 추상이며, 실제 구현은 그 인터페이스를 구현하는 클래스에게 맡긴다. 해당 인터페이스를 사용하는 입장에서는 실제 클래스가 어떻게 구현되어 있는지 몰라도 인터페이스의 생김새에 따라 함수를 호출하기만 하면 된다. 마치 복잡한 시스템의 UI(유저 인터페이스)와 같다. 구글 검색 엔진은 복잡한 시스템이지만 사용자에게 보여주는 건 질의어를 입력하는 텍스트 박스밖에 없다.<br><img src="/images/google.png" alt="구글 검색 엔진"></p>
<p></p><p style="text-align:center;color:#808080;">검색 엔진의 구현을 몰라도 검색을 할 수 있다(이미지 출처: <a href="https://www.google.com" target="_blank" rel="external">구글</a>)</p><br>추상화가 잘되어 있다는 것은 (구글 검색 엔진처럼)객체의 필요한 기능만 드러내고, 복잡하고 굳이 드러내지 않아도 되는 내용들은 숨겼다는 것을 의미한다. 이전에는 이러한 인터페이스의 추상성을 철저히 지켰기 때문에 인터페이스가 어떤 상태(인스턴스 변수)나 구현된 메서드를 갖는 것이 불가능했다. 하지만 Java 8부터 인터페이스가 조금 더 유연하게 바뀌었다.<p></p>
<h1 id="정적-메서드"><a href="#정적-메서드" class="headerlink" title="정적 메서드"></a>정적 메서드</h1><p>기술적으로 Java에서 인터페이스에 정적 메서드를 추가하지 못할 이유는 없었다. 정적 메서드는 어차피 인스턴스와 관계가 없기 때문이다. 다만 정적 메서드도 구현된 메서드라는 점에서 인터페이스의 추상성을 해친다는 것이 문제였다. Java 8에서는 그러한 제약이 없어졌고, 인터페이스에 정적 메서드를 추가할 수 있게 되었다.(사실 이전에도 인터페이스에 정적 필드는 정의할 수 있었기 때문에 정적 메서드가 Java 8에 와서야 추가된 것은 조금 의아하다.) 기존의 제약을 깨고 정적 메서드를 추가한 것은 개발 편의성을 높이려는 시도로 보인다. Java 8 이전의 표준 라이브러리에서는 인터페이스와 관련된 정적 메서드들을 동반 클래스(companion class)에서 제공했다. 대표적인 예로 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" target="_blank" rel="external">Collection</a> 인터페이스와 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html" target="_blank" rel="external">Collections</a> 동반 클래스가 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 인터페이스와 동반 클래스의 예.</span></div><div class="line">Collection&lt;String&gt; empty = Collections.emptyList();</div></pre></td></tr></table></figure>
<p>이제는 인터페이스에 바로 정적 메서드를 추가할 수 있기 때문에 동반 클래스를 따로 정의하지 않아도 된다. Java 8에 추가된 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="external">Stream</a> 인터페이스는 유용한 정적 메서드들을 제공한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Stream&lt;String&gt; chosunKings     = Stream.of(<span class="string">"태조"</span>, <span class="string">"정종"</span>, <span class="string">"태종"</span>, <span class="string">"세종"</span>, <span class="string">"문종"</span>, <span class="string">"단종"</span>, <span class="string">"세조"</span>, ...);</div><div class="line">Stream&lt;String&gt; southKoreaKings = Stream.empty();</div></pre></td></tr></table></figure>
<h1 id="기본-메서드-default-method"><a href="#기본-메서드-default-method" class="headerlink" title="기본 메서드(default method)"></a>기본 메서드(default method)</h1><p>Java 8에서는 인터페이스에 기본 구현을 정의할 수 있게되었다. 기본 구현이 제공되는 메서드는 구현 클래스에서 구현하지 않아도 컴파일이 가능하다. 기본 메서드는 기존의 인터페이스에 메서드를 추가해야하는 경우에 아주 유용하다. 인터페이스가 변경되는 일이 없도록 프로그램을 잘 작성하는게 좋겠지만 변경이 불가피한 상황이 생길 수도 있다. 인터페이스에 메서드를 추가하면 해당 인터페이스를 구현하는 모든 클래스에서 추가된 메서드를 구현해야하기 때문에 문제가 생긴다. 구현 클래스가 9개라면 인터페이스까지 10개의 파일을 수정해야 한다. 하지만 추가되는 메서드의 구현이 대부분 동일하다면 인터페이스에 기본적인 메서드 구현을 정의하고 유별난 클래스만 수정해주면 된다. 연료 유형을 포함하는 <code>Car</code> 인터페이스를 예로 들어보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">fuelType</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>연료 유형에 따른 구현 클래스들도 있다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DieselCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fuelType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"DIESEL"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GasolineCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fuelType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"GASOLINE"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>자동 주행 차량에 발빠르게 대응하기 위해서 <code>Car</code> 인터페이스에 자동 주행 차량 여부를 확인할 수 있는 메서드가 추가되어야한다고 생각해보자. <code>Car</code>는 아래와 같이 변경되어야 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">fuelType</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">autodrive</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 경우에 <code>autodrive()</code> 메서드는 기본 구현을 제공하지 않으므로 <code>DieselCar</code>, <code>GasolineCar</code>에서 구현해줘야 한다. 하지만 기존 차량들은 자율 주행이 안될 것이기 때문에 아래와 같이 기본 구현을 제공할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">fuelType</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">autodrive</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>autodrive()</code>는 <code>FutureCar</code>와 같은 유별난 클래스에서만 따로 구현해주면 된다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fuelType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"SOLAR"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">autodrive</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>인터페이스의 기본 메서드는 클래스의 계층을 좀 더 단순하게 만들어준다는 장점도 있다. Java 2부터 있어왔던 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html" target="_blank" rel="external">AbstractCollection</a>은 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" target="_blank" rel="external">Collection</a> 구현 클래스들의 공통 기능을 제공한다. Java 8 이전에는 구현 클래스들의 공통 기능들을 묶기 위해 인터페이스와 구현 클래스 사이에 추상 클래스를 정의하는 것이 일반적이었다. 하지만 Java 8에 와서는 더 이상 추상 클래스를 추가할 필요 없이 기본 메서드를 정의할 수 있게 되었다. 이런 변화로 인터페이스와 추상 클래스의 경계가 모호해졌다는 느낌이 들지만 여전히 인스턴스 변수의 유무 차이는 존재한다.</p>
<h1 id="기본-메서드의-충돌-해결하기"><a href="#기본-메서드의-충돌-해결하기" class="headerlink" title="기본 메서드의 충돌 해결하기"></a>기본 메서드의 충돌 해결하기</h1><p>Java에서 하나의 클래스는 여러 인터페이스를 구현할 수 있다. Java 8 이전에는 여러 인터페이스가 같은 메서드를 갖더라도 어차피 구현은 클래스에서만 제공했기 때문에 문제가 되지 않았다. 하지만 Java 8에서 인터페이스들이 각각 동일한 메서드의 기본 구현을 제공하고, 클래스에서 충돌이 발생하는 메서드를 명시적으로 오버라이드 하지 않으면 컴파일러가 어떤 기본 메서드를 사용해야할 지 선택할 수 없기 때문에 문제가 발생한다. 책에 나와있는 예시를 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Identified</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Math.abs(hashCode()); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Person</span>, <span class="title">Identified</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Person</code>과 <code>Identified</code> 인터페이스는 <code>getId()</code> 기본 메서드를 정의하고 있고, <code>Employee</code> 클래스는 두 인터페이스를 구현한다. <code>Employee</code> 클래스에서 <code>getId()</code>를 오버라이드 하지 않으면 <strong>Employee inherits unrelated defaults for getId() from types Person and Identified</strong> 라는 컴파일 에러가 발생한다.</p>
<p>한 쪽에서 기본 메서드를 구현하지 않으면 문제가 해결될까? <code>Identified</code>를 아래와 같이 기본 메서드 구현을 하지 않도록 바꾸고 컴파일 해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Identified</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>될 것 같지만 메시지가 <strong>Employee is not abstract and does not override abstract method getId() in Identified</strong> 라고 바뀔 뿐 여전히 컴파일은 되지 않는다. <code>Person</code>과 <code>Identified</code> 인터페이스가 동일한 메서드를 갖고 있긴 하지만 컴파일러 입장에서는 두 개가 정말 같은 목적의 메서드인지 알 길이 없다. 따라서 같은 모양의 메서드지만 두 메서드를 다른 것으로 보고 클래스가 <code>Identified</code>를 구현하지 않았다고 판단한다.(개인적으로는 이것이 일관성이 부족하다고 생각하는데 그 이유는 두 인터페이스 모두 기본 메서드를 구현하지 않는 경우에는 충돌이 일어나지 않기 때문이다.)</p>
<p>가장 좋은 해결 방안은 충돌이 나는 경우를 만들지 않는 것이다. 두 인터페이스가 동일한 메서드를 갖고 있다면 인터페이스 간에 상속 관계가 있지는 않은지, 메서드 이름을 너무 포괄적으로 정한 것은 아닌지 따져보고 충돌 상황을 피하는 게 좋다.</p>
<p>메서드 이름이나 기본 메서드 구현을 포기하지 않고 컴파일 에러를 해결하는 방법은 아래와 같다.</p>
<h2 id="클래스에서-충돌-메서드-구현"><a href="#클래스에서-충돌-메서드-구현" class="headerlink" title="클래스에서 충돌 메서드 구현"></a>클래스에서 충돌 메서드 구현</h2><p>가장 단순한 방법으로 클래스에서 충돌 메서드의 구현을 덮어 버리는 것이다. 이 때 클래스에서 구현을 새로 할 수도 있지만 어느 한 쪽의 기본 메서드를 사용할 수도 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Person</span>, <span class="title">Identified</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Person의 기본 메서드를 사용하고 싶은 경우.</span></div><div class="line">        <span class="comment">// Identified의 기본 메서드를 사용하려면 Identified.super.getId()를 반환한다.</span></div><div class="line">        <span class="keyword">return</span> Person.<span class="keyword">super</span>.getId();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="인터페이스간-상속"><a href="#인터페이스간-상속" class="headerlink" title="인터페이스간 상속"></a>인터페이스간 상속</h2><p><code>Person</code> 인터페이스가 <code>Identified</code>를 상속받도록 하면 <code>Employee</code>에 구현 메서드가 없어도 문제를 해결할 수 있다. 하지만 이런 결정을 하기 전에 인터페이스 사이의 관계를 잘 고려해야한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Identified</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Identified</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Math.abs(hashCode()); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이렇게 하면 <code>Employee</code>는 결국 <code>Person</code>의 기본 메서드를 사용하게 된다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;요즘 &lt;a href=&quot;http://www.yes24.com/24/goods/23449538?scode=032&amp;amp;OzSrank=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;카이 호스트만의 코어 자바8&lt;/a&gt;로 Java 8을 공부하고 있다. 작년 초에 개발자로 전향하여 Java 8의 stream 같은 것을 &lt;del&gt;매우 신기해하며&lt;/del&gt; 어깨너머로 배워 사용했었는데 알고보니 Java 8이 처음 출시된 것은 2014년 3월 18일이었다.(&lt;a href=&quot;https://www.java.com/ko/download/faq/release_dates.xml&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java 릴리스 페이지 참고&lt;/a&gt;) 지금은 Java 9가 나오려고 몸을 들썩이는 중이다. Java 8을 제대로 공부도 해보지 않았는데 벌써 Java 9가 나온다고 하니 젊은 나이에 뒤처지는 것 같은 기분이 들었다. 이런 까닭에 황급히 서점에서 책을 사서 공부하는 중이다. 원저의 제목 &lt;a href=&quot;https://www.amazon.com/Core-Java-Impatient-Cay-Horstmann/dp/0321996321&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Core Java for the Impatient&lt;/a&gt;가 내 상황에 잘 들어맞는 것 같다. 오랜만에 블로그에 글도 올릴 겸 더 늦기 전에 Java 8을 공부하면서 중요하다고 생각하는 것들을 정리해보려고 한다.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>가상 머신으로 Hadoop-2.7.2 클러스터 구성하기</title>
    <link href="http://yoursite.com/2016-03-23/hadoop-2-7-2-cluster-with-vagrant-virtual-machines/"/>
    <id>http://yoursite.com/2016-03-23/hadoop-2-7-2-cluster-with-vagrant-virtual-machines/</id>
    <published>2016-03-23T14:50:00.000Z</published>
    <updated>2017-01-16T01:27:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>부서 배치를 받고 일주일, 말로만 듣던 하둡을 만져 볼 기회가 찾아왔다. 나는 기술 교육 기간동안 일찍 출근하던 습관이 몸에 배어서 지금도 규정 출근 시각보다 30~40분 정도 일찍 회사에 도착한다.(평생 그런 적이 없었는데 이번에 이직을 하면서 그런 인간이 되었다.) 일찍 일어나는 새가 벌레를 잡듯, 일찍 출근하니 일찍 출근하시는 이사님께서 과제를 주셨다 ㅎㅎㅎ 이사님께 받은 과제가 바로 가상 머신을 이용하여 하둡 클러스터 구성하기이다. <a id="more"></a></p>
<h1 id="가상-머신-준비"><a href="#가상-머신-준비" class="headerlink" title="가상 머신 준비"></a>가상 머신 준비</h1><p><a href="https://www.vagrantup.com/" target="_blank" rel="external">Vagrant</a> 를 이용하면 편리하게 여러 대의 가상 머신을 생성할 수 있다. <a href="https://www.vagrantup.com/" target="_blank" rel="external">Vagrant</a> 가 편리하긴 하지만 역시 공짜는 없다. 배워야 한다. 그래도 한번 배워두면 두고두고 편리하게 이용할 수 있으니 직접 가상 머신을 생성하고 띄우는 것 보다는 낫다.</p>
<p>VirtualBox가 설치되어 있으면 다음과 같은 <a href="https://www.vagrantup.com/" target="_blank" rel="external">Vagrant</a> 명령어로 CentOS-6.5 가상 머신을 띄울 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vagrant init puphpet/centos65-x64; vagrant up --provider virtualbox</div></pre></td></tr></table></figure>
<p><code>puphpet/centos65-x64</code> 은 <a href="https://atlas.hashicorp.com/boxes/search" target="_blank" rel="external">Vagrant Boxes</a>에서 찾은 CentOS-6.5 이미지이다. 우분투나 여타 다른 OS 이미지도 여기서 찾아서 사용할 수 있다. <code>vagrant init</code> 명령어를 사용하면 명령어를 실행한 위치에 <code>.vagrant/</code> 디렉터리와 <code>Vagrantfile</code> 이라는 설정 파일이 생성된다.</p>
<p><a href="https://www.vagrantup.com/" target="_blank" rel="external">Vagrant</a> 를 배우는 것은 결국 이 설정 파일을 구성하는 법을 배우는 것이다. 설정 파일은 <a href="https://www.ruby-lang.org/ko/" target="_blank" rel="external">Ruby</a> 의 문법을 따른다. 알고보니 <a href="https://www.vagrantup.com/" target="_blank" rel="external">Vagrant</a> 도 <a href="https://www.ruby-lang.org/ko/" target="_blank" rel="external">Ruby</a> 로 작성된 프로젝트였다.(시간나면 배워야겠다.)</p>
<p>나의 목적은 여러 대의 가상 머신으로 하둡 클러스터를 구성하는 것이므로 한 번에 여러 대의 머신을 띄워야 한다. <a href="https://www.vagrantup.com/" target="_blank" rel="external">Vagrant</a> 도 이제 막 써보는 단계이고, <a href="https://www.ruby-lang.org/ko/" target="_blank" rel="external">Ruby</a> 도 몰라서 어떻게 하면 되는지 구글에게 물어봤다. 결국 다음과 같은 구성을 얻게 되었다.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">boxes = [</div><div class="line">  &#123;</div><div class="line">    <span class="symbol">:name</span> =&gt; <span class="string">"master"</span>,</div><div class="line">    <span class="symbol">:eth1</span> =&gt; <span class="string">"192.168.33.10"</span>,</div><div class="line">    <span class="symbol">:mem</span> =&gt; <span class="string">"512"</span>,</div><div class="line">    <span class="symbol">:cpu</span> =&gt; <span class="string">"1"</span>,</div><div class="line">    <span class="symbol">:ssh_port</span> =&gt; <span class="string">"2260"</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="symbol">:name</span> =&gt; <span class="string">"slave1"</span>,</div><div class="line">    <span class="symbol">:eth1</span> =&gt; <span class="string">"192.168.33.12"</span>,</div><div class="line">    <span class="symbol">:mem</span> =&gt; <span class="string">"512"</span>,</div><div class="line">    <span class="symbol">:cpu</span> =&gt; <span class="string">"1"</span>,</div><div class="line">    <span class="symbol">:ssh_port</span> =&gt; <span class="string">"2280"</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="symbol">:name</span> =&gt; <span class="string">"slave2"</span>,</div><div class="line">    <span class="symbol">:eth1</span> =&gt; <span class="string">"192.168.33.13"</span>,</div><div class="line">    <span class="symbol">:mem</span> =&gt; <span class="string">"512"</span>,</div><div class="line">    <span class="symbol">:cpu</span> =&gt; <span class="string">"1"</span>,</div><div class="line">    <span class="symbol">:ssh_port</span> =&gt; <span class="string">"2290"</span></div><div class="line">  &#125;</div><div class="line">]</div><div class="line"></div><div class="line">Vagrant.configure(<span class="number">2</span>) <span class="keyword">do</span> <span class="params">|config|</span></div><div class="line">  config.vm.box = <span class="string">"puphpet/centos65-x64"</span></div><div class="line"></div><div class="line">  config.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|v, override|</span></div><div class="line">    override.vm.box = <span class="string">"puphpet/centos65-x64"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  boxes.each <span class="keyword">do</span> <span class="params">|opts|</span></div><div class="line">    config.vm.define opts[<span class="symbol">:name</span>] <span class="keyword">do</span> <span class="params">|config|</span></div><div class="line">      config.vm.hostname = opts[<span class="symbol">:name</span>]</div><div class="line"></div><div class="line">      config.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|v|</span></div><div class="line">        v.customize [<span class="string">"modifyvm"</span>, <span class="symbol">:id</span>, <span class="string">"--memory"</span>, opts[<span class="symbol">:mem</span>]]</div><div class="line">        v.customize [<span class="string">"modifyvm"</span>, <span class="symbol">:id</span>, <span class="string">"--cpus"</span>, opts[<span class="symbol">:cpu</span>]]</div><div class="line">      <span class="keyword">end</span></div><div class="line"></div><div class="line">      config.vm.network <span class="symbol">:private_network</span>, <span class="symbol">ip:</span> opts[<span class="symbol">:eth1</span>]</div><div class="line">      config.vm.network <span class="string">"forwarded_port"</span>, <span class="symbol">guest:</span> <span class="number">22</span>, <span class="symbol">host:</span> opts[<span class="symbol">:ssh_port</span>], <span class="symbol">id:</span> <span class="string">"ssh"</span>, <span class="symbol">auto_correct:</span> <span class="literal">true</span></div><div class="line"></div><div class="line">      config.ssh.port = opts[<span class="symbol">:ssh_port</span>]</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p><code>puphpet/centos65-x64</code> 이미지로 서버를 만들면 vagrant 계정이 만들어진다. 비밀번호는 vagrant이고 이 계정으로 <code>sudo</code> 명령어를 수행할 수 있다. 이렇게 구성을 마치고 <code>$ vagrant up</code> 명령어를 수행하면 가상 머신 세 대가 생성되고 실행된다. 각 머신은 hadoop에서 다음 역할을 수행한다.</p>
<p><strong>master: namenode</strong><br><strong>slave1: datanode</strong><br><strong>slave2: datanode</strong></p>
<p>그럼 이제 하둡 클러스터를 구성해보자.</p>
<h1 id="준비-사항-모든-머신"><a href="#준비-사항-모든-머신" class="headerlink" title="준비 사항(모든 머신)"></a>준비 사항(모든 머신)</h1><p>ssh, sshd, rsync, java를 설치해야 한다. ssh, sshd는 CentOS-6.5에 포함되어 있으므로 java만 설치하도록 하자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo yum install -y java-1.7.0-openjdk-devel</div></pre></td></tr></table></figure>
<p>하둡은 $JAVA_HOME 변수를 참조한다. 나는 <code>/etc/profile.d/hadoop.sh</code> 에서 $JAVA_HOME 변수를 export 하도록 하였다. 하둡은 IPv6 network를 지원하지 않는다. 두번째 변수는 IPv4를 사용하도록 java 파라미터를 넣어준다. 마지막 줄에서는 hadoop 설정 파일의 위치를 지정해준다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$JAVA_HOME</span>"</span> = <span class="string">""</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.95.x86_64</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$HADOOP_OPTS</span>"</span> = <span class="string">""</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">export</span> HADOOP_OPTS=-Djava.net.preferIPv4Stack=<span class="literal">true</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$HADOOP_CONF_DIR</span>"</span> = <span class="string">""</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">export</span> HADOOP_CONF_DIR=/opt/hadoop/hadoop/etc/hadoop</div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<h1 id="계정-생성-모든-머신"><a href="#계정-생성-모든-머신" class="headerlink" title="계정 생성(모든 머신)"></a>계정 생성(모든 머신)</h1><p>hadoop을 실행할 계정을 만들자(계정 이름이 hadoop이 아니어도 된다.)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo useradd hadoop</div><div class="line">$ sudo passwd hadoop</div></pre></td></tr></table></figure>
<h1 id="서버간-ssh-접속-설정-모든-머신"><a href="#서버간-ssh-접속-설정-모든-머신" class="headerlink" title="서버간 ssh 접속 설정(모든 머신)"></a>서버간 ssh 접속 설정(모든 머신)</h1><p>서버간 비밀번호 입력없이 ssh 접속을 할 수 있게 설정해야 한다. 우선 서버끼리 이름으로 접속할 수 있도록 <code>/etc/hosts</code> 파일을 수정하자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">192.168.33.10 master</div><div class="line">192.168.33.11 secondary</div><div class="line">192.168.33.12 slave1</div><div class="line">192.168.33.13 slave2</div></pre></td></tr></table></figure>
<p>호스트 파일(ex. master 머신)에 <code>127.0.0.1 master localhost ...</code> 이런 내용이 있을 수 있다. <code>127.0.0.1 master</code> 는 나중에 문제가 될 수 있으므로 <code>127.0.0.1 master</code>는 지워주자. <code>127.0.0.1 localhost</code> 는 지우지 않아도 된다. 아니면 마음 편히 기존에 있던 내용은 다 지우고 위와 같이 설정해줘도 된다.</p>
<p><code>/etc/hosts</code> 파일 설정이 완료되었으면 1에서 생성한 계정으로 바꾸어 서버마다 key를 생성하고 공유해줘야 한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ su hadoop</div><div class="line">$ ssh-keygen -t rsa</div><div class="line">$ ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop@master</div><div class="line">$ ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop@slave1</div><div class="line">$ ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop@slave2</div><div class="line">$ chmod 0600 ~/.ssh/authorized_keys</div><div class="line">$ <span class="built_in">exit</span></div></pre></td></tr></table></figure>
<p><strong>※ 자기 자신도 ssh로 접속할 수 있도록 모든 머신에 위 명령어를 실행해야 한다.</strong></p>
<h1 id="Hadoop-2-7-2-설치-master만"><a href="#Hadoop-2-7-2-설치-master만" class="headerlink" title="Hadoop-2.7.2 설치(master만)"></a>Hadoop-2.7.2 설치(master만)</h1><p>이제 하둡을 설치해 보자. 설치 경로는 달라도 상관 없다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ sudo mkdir /opt/hadoop</div><div class="line">$ <span class="built_in">cd</span> /opt/hadoop/</div><div class="line">$ sudo wget http://apache.mirror.cdnetworks.com/hadoop/common/hadoop-2.7.2/hadoop-2.7.2.tar.gz</div><div class="line">$ sudo tar -xzf hadoop-2.7.2.tar.gz</div><div class="line">$ sudo mv hadoop-1.2.0 hadoop</div><div class="line">$ sudo chown -R hadoop /opt/hadoop</div><div class="line">$ <span class="built_in">cd</span> /opt/hadoop/hadoop/</div></pre></td></tr></table></figure>
<h1 id="Hadoop-공통-설정-master만"><a href="#Hadoop-공통-설정-master만" class="headerlink" title="Hadoop 공통 설정(master만)"></a>Hadoop 공통 설정(master만)</h1><p><strong><code>core-site.xml</code></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ su hadoop</div><div class="line">$ <span class="built_in">cd</span> /opt/hadoop/hadoop</div><div class="line">$ vi etc/hadoop/core-site.xml</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://master:9000/<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.permissions<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong><code>hdfs-site.xml</code></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi etc/hadoop/hdfs-site.xml</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/hadoop/hadoop/hdfs/namenode<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/hadoop/hadoop/hdfs/datanode<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong><code>yarn-site.xml</code></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi etc/hadoop/yarn-site.xml</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8030<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8032<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8088<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8031<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.admin.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8033<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
<p>여기까지 하고 설치한 하둡 디렉터리 통째로 slave1, slave2에 복사해주자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> /opt/hadoop</div><div class="line">$ scp -r hadoop hadoop-slave-1:/opt/hadoop</div><div class="line">$ scp -r hadoop hadoop-slave-2:/opt/hadoop</div></pre></td></tr></table></figure>
<h1 id="Hadoop-마스터-설정-master만"><a href="#Hadoop-마스터-설정-master만" class="headerlink" title="Hadoop 마스터 설정(master만)"></a>Hadoop 마스터 설정(master만)</h1><p>4에서 설정한 파일들은 master 머신에서만 수정을 하긴 했지만 namenode든 datanode든 공통적으로 필요한 내용이라 설정한 내용을 모두 slave1, slave2에 복사하였다. 이제는 master에 필요한 설정을 해주자.</p>
<p><strong><code>mapred-site.xml</code></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi etc/hadoop/mapred-site.xml</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobtracker.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:9001<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong><code>slave</code></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi etc/hadoop/slave</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">slave1</div><div class="line">slave2</div></pre></td></tr></table></figure>
<h1 id="하둡-클러스터-구동-master만"><a href="#하둡-클러스터-구동-master만" class="headerlink" title="하둡 클러스터 구동(master만)"></a>하둡 클러스터 구동(master만)</h1><p><strong>Namenode 포맷</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/hdfs namenode -format</div></pre></td></tr></table></figure>
<p><strong>Distributed Format System 시작</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sbin/start-dfs.sh</div></pre></td></tr></table></figure>
<p><strong>YARN MapReduce Job Tracker 시작</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sbin/start-yarn.sh</div></pre></td></tr></table></figure>
<h1 id="동작-확인"><a href="#동작-확인" class="headerlink" title="동작 확인"></a>동작 확인</h1><p>PC에서 <a href="http://192.168.33.10:50070" target="_blank" rel="external">http://192.168.33.10:50070</a> 으로 정상적으로 접속되는지 확인해보자. Namenode와 Datanode가 정상적으로 연동 된다면 <code>Live Nodes</code> 라는 칸에 Datanode의 개수 2가 표시된다.</p>
<h2 id="WordCount-예제-실행"><a href="#WordCount-예제-실행" class="headerlink" title="WordCount 예제 실행"></a>WordCount 예제 실행</h2><p><a href="https://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html" target="_blank" rel="external">WordCount</a>는 프로그래밍 기초로 치면 “Hello, World” 예제라고 볼 수 있다. 링크를 따라가 예제를 실행해보자.</p>
<p>다음과 같은 결과를 얻는다면 성공이다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ bin/hadoop fs -cat /user/hadoop/wordcount/output/*</div><div class="line">Bye 1</div><div class="line">Goodbye 1</div><div class="line">Hadoop 2</div><div class="line">Hello 2</div><div class="line">World 2</div></pre></td></tr></table></figure>
<p>위에 내가 적어둔대로 한다고 100% 하둡 클러스터가 문제없이 동작할 것이라는 보장은 없다. 아마 제대로 동작하지 않을 확률이 더 높을 것이다. 내가 쓴 글이 잘못되었을 수도 있고, 따라하는 과정에서 실수가 있을 수 있다. 나도 여러 튜토리얼을 보고 따라했지만 그대로 되진 않았다. 하둡 클러스터를 구성하면서 배운 점은 잘 안되면 무조건 로그를 봐야 한다는 것이다. 나는 이 클러스터를 구성하는데 이틀이 걸렸다. <code>jps</code> 를 쳐보면 namenode의 프로세스도 잘 떠있고, datanode의 프로세스도 잘 떠 있는데도 namenode에서 datanode를 인식하지 못했다. 답답한 마음에 구글님께 여쭤봤지만 같은 문제라도 원인은 천차만별이었다. 결국 로그를 뒤져보니 datanode에서 namenode로 연결이 안되는 문제였다. 이 문제는 namenode의 <code>/etc/hosts</code> 파일의 127.0.0.1 master를 지우면서 해결되었다. 클러스터 구성에 문제가 생겼다면 구글에게 물어보기 전에 로그를 한 번 열어보자 :)</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p><a href="https://chawlasumit.wordpress.com/2015/03/09/install-a-multi-node-hadoop-cluster-on-ubuntu-14-04/" target="_blank" rel="external">https://chawlasumit.wordpress.com/2015/03/09/install-a-multi-node-hadoop-cluster-on-ubuntu-14-04/</a><br><a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/SingleCluster.html" target="_blank" rel="external">http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/SingleCluster.html</a><br><a href="http://mudchobo.tistory.com/541" target="_blank" rel="external">http://mudchobo.tistory.com/541</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;부서 배치를 받고 일주일, 말로만 듣던 하둡을 만져 볼 기회가 찾아왔다. 나는 기술 교육 기간동안 일찍 출근하던 습관이 몸에 배어서 지금도 규정 출근 시각보다 30~40분 정도 일찍 회사에 도착한다.(평생 그런 적이 없었는데 이번에 이직을 하면서 그런 인간이 되었다.) 일찍 일어나는 새가 벌레를 잡듯, 일찍 출근하니 일찍 출근하시는 이사님께서 과제를 주셨다 ㅎㅎㅎ 이사님께 받은 과제가 바로 가상 머신을 이용하여 하둡 클러스터 구성하기이다.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>학습 테스트를 작성하자!</title>
    <link href="http://yoursite.com/2016-03-13/training-test/"/>
    <id>http://yoursite.com/2016-03-13/training-test/</id>
    <published>2016-03-13T14:50:00.000Z</published>
    <updated>2017-01-16T01:27:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>프로젝트를 진행하다보면 새로운 API나 사용해 본 적 없는 라이브러리를 사용해야 하는 때가 찾아온다. 기존 프로젝트에서 사용해 본 익숙한 라이브러리라면 API를 어떻게 사용하면 되고, 이 API가 어떻게 동작할 지 예측할 수 있다. 하지만 처음 사용해 보는 것이라면 얘기가 다르다. 이 라이브러리가 프로젝트의 요구사항에 부합하는지, 예상한 대로 동작하는지 확인해 볼 필요가 있다. 이런 경우에 개발자들은 어떻게 라이브러리를 검증해야 할까? <a id="more"></a> 다음과 같은 선택지가 있다.</p>
<ol>
<li>제품 코드에 직접 적용하여 테스트 해본다.</li>
<li>연습용 프로젝트를 만들어서 테스트 해본다.</li>
<li><strong>학습 테스트를 작성한다.</strong></li>
</ol>
<p>1, 2번은 나같이 경험이 적은 개발자들이 쉽게 생각할 수 있는 선택지이다. 1번에 대해 얘기해보자. 이미 잘 동작하는 코드도 있고, 내가 주로 하는 일이 이 프로젝트를 실행시켜서 디버깅하는 일이다. 자주 수정하고, 실행해보던 코드에 새로운 라이브러리를 적용해보면 라이브러리의 동작을 빨리 확인해 볼 수 있다. 탈없이 라이브러리의 기능을 확인하고 라이브러리가 예상과 같이 동작한다면 제품에 바로 적용이 되므로 좋을 것 같다. 하지만 개발자에게 이러한 행운이 따르리란 보장은 없다. 보통은 새로운 API를 사용하는 데 서툴러 이것 저것 고치게 된다. 그러다보면 기존에 잘 동작하던 코드까지 망칠 수 있으므로 좋은 방법이라 볼 수 없다.</p>
<p>2번은 어떨까. 우선 1번의 문제는 피해갈 수 있다. 예제용 프로젝트를 따로 만들어서 테스트하면 기존 프로젝트에 영향은 없다. 예제 프로젝트를 새로 만드는 것이 어려운 것도 아니다. IDE를 몇 번 클릭하면 새로운 프로젝트가 뚝딱 생겨난다. 하지만 이 방법도 그리 영리한 것이라고 볼 순 없다. 실제 프로젝트는 많은 라이브러리와 직접 작성한 모듈들이 맞물려 동작한다. 실제 프로젝트와 같은 환경의 예제 프로젝트를 만드는 것은 생각보다 간단한 일이 아닐 수 있다. 실제 프로젝트와 같은 환경을 구축하는 데 시간을 허비하면 그만큼 테스트 코드를 작성하는 시간이 줄어든다. 또한 예제 프로젝트는 관리가 어렵다는 단점이 있다. 예제 프로젝트를 버전 관리 시스템에 올려 놓기는 조금 찝찝하다. 그렇다고 로컬에만 저장해놓으면 팀원들과 공유도 되지 않고, 시간이 지나면 자신도 그 존재를 잊게 될 것이다.</p>
<p>1, 2번의 문제를 깔끔하게 해결할 수 있는 것이 바로 학습 테스트를 작성하는 것이다. 학습 테스트는 말그대로 새로운 라이브러리를 학습 하기 위한 테스트이다. 테스트 코드는 다른 단위 테스트, 통합 테스트 코드와 마찬가지로 프로젝트 내에서 작성한다. 다른 테스트와 차이라면 내가 작성한 모듈이 아닌 외부 라이브러리의 동작을 확인하는 데 쓰인 다는 것이다. 테스트 코드는 테스트 할 때만 동작하므로 제품 코드의 동작에 전혀 영향을 주지 않는다.<br><em>(사실 가끔 테스트 코드가 제품 코드에 영향을 주기도 한다. 만약 제품 코드가 테스트하기 어려운 구조로 작성되어 있다면 테스트하기 쉽도록 리팩토링을 해줘야 한다. 이것은 옳은 방향이므로 학습 테스트의 부작용이라고 할 순 없다.)</em><br>또한 학습 테스트는 실제 프로젝트 안에 작성하게 되므로 실제 프로젝트와 같은 환경을 만드려는 노력을 하지 않아도 된다. 테스트 내에서 기존에 쓰던 라이브러리와 기존에 작성된 모듈을 그대로 사용할 수 있으므로 연습용 프로젝트를 만드는 것 보다 더 정확한 테스트를 수행할 수 있다. 마지막으로 학습 테스트는 프로젝트의 자산이 된다는 장점이 있다. 실제 프로젝트 내에 존재하므로 학습 테스트도 버전 관리가 가능하다. 그러면 필요에 따라 학습 테스트에 추가적인 케이스를 추가할 수 있고, 팀원들과 공유도 가능해진다. 테스트하고자 하는 라이브러리의 새 버전이 릴리즈되었을 때도 학습 테스트는 유용하게 쓰인다. 새 버전이 이전 버전과 호환이 되는지, 우리 팀이 기대하는 대로 동작하는지 학습 테스트가 알아서 해준다.</p>
<p>위와 같이 학습 테스트는 장점이 아주 많다. 문제는 나처럼 경험이 적은 개발자들이 학습 테스트를 작성하는 데 익숙하지 않다는 것이다. 다른 사람이 작성한 라이브러리를 우리 프로젝트에서 테스트 한다는 것이 조금 생소할 수 있다. 이제부터 익숙해지면 된다. 프로젝트는 내가 책임져야 하므로 내가 테스트를 해야 한다. 그리고 위와 같이 장점이 많은데도 학습 테스트를 작성하지 않을 이유가 없다. 혹시 지금 1, 2번과 같은 작업을 하고 있다면 다시 생각해보자. 그리고 학습 테스트를 작성하자!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;프로젝트를 진행하다보면 새로운 API나 사용해 본 적 없는 라이브러리를 사용해야 하는 때가 찾아온다. 기존 프로젝트에서 사용해 본 익숙한 라이브러리라면 API를 어떻게 사용하면 되고, 이 API가 어떻게 동작할 지 예측할 수 있다. 하지만 처음 사용해 보는 것이라면 얘기가 다르다. 이 라이브러리가 프로젝트의 요구사항에 부합하는지, 예상한 대로 동작하는지 확인해 볼 필요가 있다. 이런 경우에 개발자들은 어떻게 라이브러리를 검증해야 할까?
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>엔티티(Entity)와 값 객체(Value Object)의 차이</title>
    <link href="http://yoursite.com/2016-02-06/difference-between-entity-and-value-object/"/>
    <id>http://yoursite.com/2016-02-06/difference-between-entity-and-value-object/</id>
    <published>2016-02-05T17:33:00.000Z</published>
    <updated>2017-01-16T01:27:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.yes24.com/24/goods/13159413?scode=032&amp;OzSrank=2" target="_blank" rel="external">자바 웹 개발 워크북</a>을 공부하면서 값 객체(Value Object)라는 개념을 처음 보게 되었다. 책에서는 값 객체를 값을 전달하는 역할을 하는 객체라고 설명한다. 개념을 소개하는 부분에서는 그런 개념이구나 하고 넘어갔는데 책의 중반부로 가니 예제에서 DB 테이블과 매핑되는 모든 객체들을 값 객체로 다루고 있었다. <a id="more"></a>  MVC에서 Model에 해당되는 부분이 단지 DB에서 값만 읽어 오는 역할 밖에 못하나 하는 생각이 들었다. 예전에 .NET Framework 기반에서 개발을 할 때는 ORM 프레임워크에서 테이블과 매핑해주는 객체를 엔티티(Entity)라고 불렀다. 같은 개념을 Java에서는 값 객체라 하고, .NET 에서는 엔티티라고 부르는 것일까? 이런 의문들이 생겨 구글에 검색해보니 명쾌하게 설명해주는 글이 있었다. 이 글이 신빙성이 있는지 확신은 할 수 없지만 구글에서 ‘difference between entity and value object’라고 검색했을 때 가장 위에 위치한 것을 보아 충분히 읽어볼 만한 글이라 생각한다. 그리고 내가 공부삼아 굳이 번역을 하긴 했지만 원문이 어렵지 않으므로 되도록 원문을 읽어보길 바란다.</p>
<hr>
<p><a href="http://culttt.com/2014/04/30/difference-entities-value-objects/" target="_blank" rel="external">원문 보기</a></p>
<p>여러분은 컴퓨터 프로그래밍을 하면 할 수록 엄청나게 많은 새로운 이론과 개념들을 맞닥뜨리게 된다. 그 중에서 직관적으로 이해되지 않는 하나는 바로 값 객체(Value Object)이다. 값 객체는 도메인 주도 설계(Domain Driven Design)에서 중요한 개념이다.당장 도메인 주도 설계에 대해 잘 모른다 하더라도 이 글을 이해하는 데 문제는 없다. 이 글은 값 객체를 설명하는 데 초점을 두고 있다. 하지만 이 글이 여러분이 추후 도메인 주도 설계를 이해하는 첫 걸음이 되기를 희망한다.</p>
<p>참고: 이 글은 여러분이 객체 지향 프로그래밍(Object Oriented Programming)에 대해 잘 알고 있다고 가정한다. 그렇지 않다면 객체 지향 프로그래밍에 대해 먼저 학습하고 오길 바란다.</p>
<h2 id="엔티티-vs-값-객체"><a href="#엔티티-vs-값-객체" class="headerlink" title="엔티티 vs 값 객체"></a>엔티티 vs 값 객체</h2><p>객체 지향 프로그래밍에서는 관련된 속성과 메서드를 객체로 표현한다. 예를 들어, 어플리케이션 상에서 사람은 객체가 될 수 있다. 사람은 이름, 이메일, 비밀번호 등 많은 속성을 지닌다. 데이터베이스에서는 이 사람을 <code>id</code> 로 식별한다. 이는 사람이 자신의 이름, 이메일, 비밀번호를 바꾸더라도 <code>id</code> 가 바뀌지 않으면 같은 사람임을 의미한다. 이렇게 속성이 바뀌더라도 여전히 같은 것으로 인식되는 객체를 엔티티라고 한다. 엔티티는 속성이 바뀔 수 있기 때문에 가변(mutable) 객체다. 엔티티의 정체성은 <code>id</code> 로 표현된다.</p>
<p>우리 어플리케이션이 사람의 현재 위치를 기록할 수 있다고 상상해보자. 그 사람이 성공적으로 인터넷에 연결하고 우리 어플리케이션에 인증을 하면 새로운 위치 객체가 생성된다. 위치 객체는 위도와 경도 값을 가진다. 우리는 위치 객체가 어떤 위치 정보를 담고 있는지에만 관심이 있기 때문에 위치 객체는 값 객체가 된다.</p>
<p>어떤 사람의 위치가 바뀌었을 때 우리는 기존의 위치 객체를 갱신하지 않는다. 단순히 새로운 위치 객체를 생성한다. 위치 객체는 생성된 이후로 소멸될 때까지 자신의 속성을 변경하지 않는다. 객체의 속성이 바뀔 수 없을 때, 그 객체를 불변(immutable) 객체라고 한다.</p>
<p>또한 값 객체는 식별자에 의해 같음(equality)이 결정되지 않는다. 예를 들어 당신이 같은 위도와 경도를 가진 위치 객체를 두 개 생성했다면 그 두 객체는 같은 객체이다. 반면에 사람 객체는 <code>id</code> 라는 고유한 식별자로 같음을 판단한다. 같은 이름을 가진 두 개의 사람 객체가 있다고 해도 두 객체는 같지 않을 수 있다.</p>
<h2 id="어떻게-값-객체를-식별할까"><a href="#어떻게-값-객체를-식별할까" class="headerlink" title="어떻게 값 객체를 식별할까?"></a>어떻게 값 객체를 식별할까?</h2><p>이제 우리는 어떤 객체가 <code>id</code> 로 식별된다면 엔티티로, 그렇지 않다면 값 객체라고 구분할 수 있다. 엔티티의 속성은 바뀔 수 있다. 하지만 엔티티는 고유한 식별자로 표현되기 때문에 우리 시스템 상에서 같은 객체로 인식된다. 반면 값 객체는 갖고 있는 값으로표현되는 객체이다. 한번 생성되면 그 값을 바꿀 수 없으며, 우리는 그것이 어떤 개체인지 신경쓰지 않는다.</p>
<p>언제 엔티티를 쓰고, 값 객체를 써야할지 어떻게 알 수 있을까? 그것은 어플리케이션의 상황에 따라 결정된다. 처음 예시로 돌아가보자. 우리 어플리케이션은 더이상 단순한 소셜 서비스가 아니다. 포스퀘어와 동일 다고 가정해보자. 모든 위치 객체는 고유한 식별자를 지닌다. 많은 사람들이 같은 위치에서 체크인을 할 수 있기 때문이다. 이제 위치 객체는 더이상 값 객체가 아닌 엔티티가 된다.</p>
<p>예제를 바꿔보자. 우리가 파워 플랜트의 소유자라고 상상해보라. 파워 플랜트는 철책(securify fence) 주변에서 일어나는 모든 활동을 기록한다. 감시의 목적으로 철책 주변의 많은 위치에서 활동이 기록된다. 이 때 우리는 특정 위치에서 일어나는 활동에 대해 관심이 있기 때문에 철책 주변의 위치는 엔티티가 된다. 수상한 사람이 우리가 감시하는 위치로 들어오게 되면 그 사건은 데이터베이스에 저장된다. 이 예제에서 사람은 값 객체이다. 우리는 감시중인 위치에 들어 온 사람이 어떤 사람인지 관심이 없기 때문이다. 단지 그 사람이 감시중인 위치에 걸려들었을 뿐이다.</p>
<p>위의 예제와 보았듯 어떤 객체가 엔티티인지 값 객체인지는 여러분의 어플리케이션이 그것을 어떻게 사용할 것인지에 달려있다. 일반적으로 위치, 날짜, 숫자, 금액은 값 객체인 경우가 많다. 그리고 사람, 제품, 파일, 판매는 엔티티인 경우가 대부분이다.</p>
<h2 id="왜-값-객체와-엔티티를-구분하는-것이-중요할까"><a href="#왜-값-객체와-엔티티를-구분하는-것이-중요할까" class="headerlink" title="왜 값 객체와 엔티티를 구분하는 것이 중요할까?"></a>왜 값 객체와 엔티티를 구분하는 것이 중요할까?</h2><p>여러분은 <strong>왜 값 객체와 엔티티의 구분이 중요할까?</strong> 하고 생각할지 모른다. 이것은 다음과 같은 이유로 매우 중요하다.</p>
<p>첫 번째로, 여러분이 같은 속성을 가진 두 개의 엔티티를 갖고 있을 때, 두 객체는 다른 <code>id</code> 를 갖고 있기 때문에 같지 않다. 하지만 같은 속성을 가진 두 값 객체를 갖고 있는 경우에 이 두 객체는 같은 객체이므로 두 객체를 자유롭게 바꿔서 쓸 수 있다. 한 객체를 다른 객체로 대체할 수 있을 때 그 객체는 값 객체이다. 반면 엔티티는 다른 것으로 교체할 경우 원치않는 부작용이 발생하게 된다.</p>
<p>두 번째로, 오랜 시간동안 엔티티의 속성은 변하지만 여전히 그것은 같은 엔티티이다. 어떤 사용자가 자신의 이메일 주소를 변경하는 것이 그 예이다. 하지만 어플리케이션이 값 객체의 속성을 변경하려고 할 때, 그 객체는 사라지고 새로운 객체가 대신하게 된다. 결제를 할 때 당신이 냈던 돈이 거스름돈이 되어 다시 돌아오지 않는다. 당신은 낮은 금액의 새로운 돈 객체를 받는다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>엔티티와 값 객체의 차이는 도메인 주도 설계에서 중요한 개념이다. 우리가 어플리케이션에서 실제 세계를 모델링할 때 이 차이는 아주 중요하다. 이 글에서 언급했듯이 여러분이 어떤 것을 개발하는지 이해하는 것이 중요하다. 어떤 어플리케이션을 만드냐에 따라 어떤 객체가 엔티티가 될지 값 객체가 될지 결정된다. 언뜻 보기에 어떤 객체가 식별자를 가져야 할 것 같다고 해서 무작정 그것을 엔티티로 만들면 안된다. 불변 객체가 되어야 할 개념을 엔티티로 모델링하면 원치 않는 부작용이 발생할 수 있다.</p>
<p>불변 객체는 어플리케이션이 의도한 대로 동작하게 하는 중요한 요소이다. 돈과 같은 것을 모델링할 때 값 객체를 사용하면 그것이 시간에 따라 변하지 않는다는 것을 보장해준다.</p>
<p>엔티티와 값 객체의 차이가 항상 뚜렷하지는 않다. 때로 그 차이를 구분하는 것은 여러분이 만들고자 하는 어플리케이션에 대한 완벽한 이해를 요구한다. 하지만 실제 세계를 여러분의 코드로 모델링하는 데 있어 엔티티와 값 객체의 차이를 아는 것은 매우 중요하다.</p>
<hr>
<p><a href="http://www.yes24.com/24/goods/13159413?scode=032&amp;OzSrank=2" target="_blank" rel="external">자바 웹 개발 워크북</a>은 Spring 프레임워크를 이해하는 데 아주 좋은 책이라고 생각한다. 하지만 이런 사소해보이지만 중요한 개념을 설명하는 데는 다소 소홀하지 않았나 하는 생각이 든다. 저자가 그런 것 까지 설명하면 책의 내용이 방대해질까 걱정되어 어물쩍 넘어 간 것일 수도 있겠다.</p>
<p>하지만 이런 내용을 잘못 이해하면 엉뚱한 방향으로 개발할 수 있다. 책의 예제를 보고 모든 DB와 매핑된 객체들을 값 객체로 오인하면 한 속성만 바꾸어 저장해도 될 일을 매번 객체를 생성하게 되고, 그 객체를 관리하는 다른 클래스를 만들게 될 수도 있다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.yes24.com/24/goods/13159413?scode=032&amp;amp;OzSrank=2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;자바 웹 개발 워크북&lt;/a&gt;을 공부하면서 값 객체(Value Object)라는 개념을 처음 보게 되었다. 책에서는 값 객체를 값을 전달하는 역할을 하는 객체라고 설명한다. 개념을 소개하는 부분에서는 그런 개념이구나 하고 넘어갔는데 책의 중반부로 가니 예제에서 DB 테이블과 매핑되는 모든 객체들을 값 객체로 다루고 있었다.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2016년이 밝았다</title>
    <link href="http://yoursite.com/2016-01-09/happy-new-year/"/>
    <id>http://yoursite.com/2016-01-09/happy-new-year/</id>
    <published>2016-01-09T06:50:00.000Z</published>
    <updated>2017-01-16T01:27:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>2016년이 밝았다. 올해로 다시 개발자가 되었다. 2010년 8월부터 2013년 7월까지 산업기능요원으로 복무를 한 이후로 2년반만에 개발자라는 타이틀을 되찾은 것이다. 이렇게 되기까지 많은 고민이 있었다. 나는 산업공학을 전공했고, 졸업 후 1년 간은 제조업 회사에서 일을 했다. 졸업 후 진로를 선택할 때 개발자가 되는 것을 전혀 고려하지 않았던 것은 아니다. 오히려 뛰어난 프로그래머에 대한 동경심이 있었다. <a id="more"></a> 하지만 그때는  산업공학 전공자로서 제조업에서 일하는 것이 더 좋을 것이라는 막연한 생각과 나는 좋은 프로그래머가 되지 못할 것 같다는 생각에 다른 길을 선택하게 되었다.</p>
<p>이전 회사에서도 IT 관련 부서에서 일을 했었다. 하지만 대부분의 업무는 외주업체 개발자를 관리하는 것이었고, 직접 코드를 작성하는 경우는 드물었다. 내가 직접 코드를 작성할 때는 내 노력여하에 따라 결과의 퀄리티나 업무 일정이 결정될 수 있었는데, 개발자를 관리하는 역할을 맡게 되니 중간 전달자 노릇만 하게 되고 뭔가 답답한 느낌만 들었다. 그러다보니 예전에 직접 코드를 짜던 시절이 생각나기 시작한 것이다. 산업기능요원으로 일했던 기억이 아름다운 추억처럼 포장되어 머리 속에 떠올랐다. 배우는 즐거움이 있었고, 해결 못할 것 같은 과제를 해낼 때의 짜릿함이 있었다. 물론 프로그래밍 문법 하나 제대로 이해하지 못해 버그를 만든 적도 있었고, 팀장한테 탈탈 털려서 밤새 한숨도 못잔 적도 있었다. 하지만 평생 외주 개발자 관리하는 일이나 하는 것보다 내가 만든 버그로 혼나는 것이 좋겠다는 생각이 들었다.</p>
<p>감사하게도 올해는 좋은 기회를 얻어 개발자로 일할 수 있게 되었다. 아직도 내가 좋은 개발자가 될 수 있을거란 확신은 없다. 그래도 오랜 고민 끝에 선택한 업이니 마음을 단단히 먹기로 했다. 그런 의미에서 올해 목표를 세워보았다.(목표를 달성하려면 다른 사람에게 알리는 것이 좋다고 한다 ㅎㅎ)</p>
<ol>
<li>한 달에 한 권 이상 기술 서적 읽기.</li>
<li>한 달에 한 권 이상 교양 서적 읽기.</li>
<li>한 달에 한 번 이상 블로그에 글 쓰기.</li>
<li>이틀에 한 번 30분 이상 운동하기.</li>
</ol>
<p>목표를 적는 순간부터 부담이 되지만 잘 지키기만 한다면 괜찮은 2016년을 보낼 것 같다. 좋은 개발자로 한 걸음 내딛는 올해가 되길…<br><strong>Happy New Year!</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016년이 밝았다. 올해로 다시 개발자가 되었다. 2010년 8월부터 2013년 7월까지 산업기능요원으로 복무를 한 이후로 2년반만에 개발자라는 타이틀을 되찾은 것이다. 이렇게 되기까지 많은 고민이 있었다. 나는 산업공학을 전공했고, 졸업 후 1년 간은 제조업 회사에서 일을 했다. 졸업 후 진로를 선택할 때 개발자가 되는 것을 전혀 고려하지 않았던 것은 아니다. 오히려 뛰어난 프로그래머에 대한 동경심이 있었다.
    
    </summary>
    
    
  </entry>
  
</feed>
