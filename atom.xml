<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>신재열의 블로그</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-04-20T02:39:10.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jaeyeol Shin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 8 - Interface의 변화</title>
    <link href="http://yoursite.com/2017-04-19/java8-changes-in-interface/"/>
    <id>http://yoursite.com/2017-04-19/java8-changes-in-interface/</id>
    <published>2017-04-19T07:32:00.000Z</published>
    <updated>2017-04-20T02:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>요즘 <a href="http://www.yes24.com/24/goods/23449538?scode=032&amp;OzSrank=1" target="_blank" rel="external">카이 호스트만의 코어 자바8</a>로 Java 8을 공부하고 있다. 작년 초에 개발자로 전향하여 Java 8의 stream 같은 것을 <del>매우 신기해하며</del> 어깨너머로 배워 사용했었는데 알고보니 Java 8이 처음 출시된 것은 2014년 3월 18일이었다.(<a href="https://www.java.com/ko/download/faq/release_dates.xml" target="_blank" rel="external">Java 릴리스 페이지 참고</a>) 지금은 Java 9가 나오려고 몸을 들썩이는 중이다. Java 8을 제대로 공부도 해보지 않았는데 벌써 Java 9가 나온다고 하니 젊은 나이에 뒤처지는 것 같은 기분이 들었다. 이런 까닭에 황급히 서점에서 책을 사서 공부하는 중이다. 원저의 제목 <a href="https://www.amazon.com/Core-Java-Impatient-Cay-Horstmann/dp/0321996321" target="_blank" rel="external">Core Java for the Impatient</a>가 내 상황에 잘 들어맞는 것 같다. 오랜만에 블로그에 글도 올릴 겸 더 늦기 전에 Java 8을 공부하면서 중요하다고 생각하는 것들을 정리해보려고 한다.<a id="more"></a></p>
<h1 id="인터페이스"><a href="#인터페이스" class="headerlink" title="인터페이스"></a>인터페이스</h1><p>객체 지향 프로그래밍에서 인터페이스는 기능의 생김새만 나타낸다. 인터페이스는 어떤 기능에 대한 추상이며, 실제 구현은 그 인터페이스를 구현하는 클래스에게 맡긴다. 해당 인터페이스를 사용하는 입장에서는 실제 클래스가 어떻게 구현되어 있는지 몰라도 인터페이스의 생김새에 따라 함수를 호출하기만 하면 된다. 마치 복잡한 시스템의 UI(유저 인터페이스)와 같다. 구글 검색 엔진은 복잡한 시스템이지만 사용자에게 보여주는 건 질의어를 입력하는 텍스트 박스밖에 없다.<br><img src="/images/google.png" alt="구글 검색 엔진"></p>
<p></p><p style="text-align:center;color:#808080;">검색 엔진의 구현을 몰라도 검색을 할 수 있다(이미지 출처: <a href="https://www.google.com" target="_blank" rel="external">구글</a>)</p><br>추상화가 잘되어 있다는 것은 (구글 검색 엔진처럼)객체의 필요한 기능만 드러내고, 복잡하고 굳이 드러내지 않아도 되는 내용들은 숨겼다는 것을 의미한다. 이전에는 이러한 인터페이스의 추상성을 철저히 지켰기 때문에 인터페이스가 어떤 상태(인스턴스 변수)나 구현된 메서드를 갖는 것이 불가능했다. 하지만 Java 8부터 인터페이스가 조금 더 유연하게 바뀌었다.<p></p>
<h1 id="정적-메서드"><a href="#정적-메서드" class="headerlink" title="정적 메서드"></a>정적 메서드</h1><p>기술적으로 Java에서 인터페이스에 정적 메서드를 추가하지 못할 이유는 없었다. 정적 메서드는 어차피 인스턴스와 관계가 없기 때문이다. 다만 정적 메서드도 구현된 메서드라는 점에서 인터페이스의 추상성을 해친다는 것이 문제였다. Java 8에서는 그러한 제약이 없어졌고, 인터페이스에 정적 메서드를 추가할 수 있게 되었다.(사실 이전에도 인터페이스에 정적 필드는 정의할 수 있었기 때문에 정적 메서드가 Java 8에 와서야 추가된 것은 조금 의아하다.) 기존의 제약을 깨고 정적 메서드를 추가한 것은 개발 편의성을 높이려는 시도로 보인다. Java 8 이전의 표준 라이브러리에서는 인터페이스와 관련된 정적 메서드들을 동반 클래스(companion class)에서 제공했다. 대표적인 예로 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" target="_blank" rel="external">Collection</a> 인터페이스와 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html" target="_blank" rel="external">Collections</a> 동반 클래스가 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 인터페이스와 동반 클래스의 예.</span></div><div class="line">Collection&lt;String&gt; empty = Collections.emptyList();</div></pre></td></tr></table></figure>
<p>이제는 인터페이스에 바로 정적 메서드를 추가할 수 있기 때문에 동반 클래스를 따로 정의하지 않아도 된다. Java 8에 추가된 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="external">Stream</a> 인터페이스는 유용한 정적 메서드들을 제공한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Stream&lt;String&gt; chosunKings     = Stream.of(<span class="string">"태조"</span>, <span class="string">"정종"</span>, <span class="string">"태종"</span>, <span class="string">"세종"</span>, <span class="string">"문종"</span>, <span class="string">"단종"</span>, <span class="string">"세조"</span>, ...);</div><div class="line">Stream&lt;String&gt; southKoreaKings = Stream.empty();</div></pre></td></tr></table></figure>
<h1 id="기본-메서드-default-method"><a href="#기본-메서드-default-method" class="headerlink" title="기본 메서드(default method)"></a>기본 메서드(default method)</h1><p>Java 8에서는 인터페이스에 기본 구현을 정의할 수 있게되었다. 기본 구현이 제공되는 메서드는 구현 클래스에서 구현하지 않아도 컴파일이 가능하다. 기본 메서드는 기존의 인터페이스에 메서드를 추가해야하는 경우에 아주 유용하다. 인터페이스가 변경되는 일이 없도록 프로그램을 잘 작성하는게 좋겠지만 변경이 불가피한 상황이 생길 수도 있다. 인터페이스에 메서드를 추가하면 해당 인터페이스를 구현하는 모든 클래스에서 추가된 메서드를 구현해야하기 때문에 문제가 생긴다. 구현 클래스가 9개라면 인터페이스까지 10개의 파일을 수정해야 한다. 하지만 추가되는 메서드의 구현이 대부분 동일하다면 인터페이스에 기본적인 메서드 구현을 정의하고 유별난 클래스만 수정해주면 된다. 연료 유형을 포함하는 <code>Car</code> 인터페이스를 예로 들어보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">fuelType</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>연료 유형에 따른 구현 클래스들도 있다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DieselCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fuelType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"DIESEL"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GasolineCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fuelType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"GASOLINE"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>자동 주행 차량에 발빠르게 대응하기 위해서 <code>Car</code> 인터페이스에 자동 주행 차량 여부를 확인할 수 있는 메서드가 추가되어야한다고 생각해보자. <code>Car</code>는 아래와 같이 변경되어야 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">fuelType</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">autodrive</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이 경우에 <code>autodrive()</code> 메서드는 기본 구현을 제공하지 않으므로 <code>DieselCar</code>, <code>GasolineCar</code>에서 구현해줘야 한다. 하지만 기존 차량들은 자율 주행이 안될 것이기 때문에 아래와 같이 기본 구현을 제공할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">fuelType</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">autodrive</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>autodrive()</code>는 <code>FutureCar</code>와 같은 유별난 클래스에서만 따로 구현해주면 된다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fuelType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"SOLAR"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">autodrive</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>인터페이스의 기본 메서드는 클래스의 계층을 좀 더 단순하게 만들어준다는 장점도 있다. Java 2부터 있어왔던 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/AbstractCollection.html" target="_blank" rel="external">AbstractCollection</a>은 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" target="_blank" rel="external">Collection</a> 구현 클래스들의 공통 기능을 제공한다. Java 8 이전에는 구현 클래스들의 공통 기능들을 묶기 위해 인터페이스와 구현 클래스 사이에 추상 클래스를 정의하는 것이 일반적이었다. 하지만 Java 8에 와서는 더 이상 추상 클래스를 추가할 필요 없이 기본 메서드를 정의할 수 있게 되었다. 이런 변화로 인터페이스와 추상 클래스의 경계가 모호해졌다는 느낌이 들지만 여전히 인스턴스 변수의 유무 차이는 존재한다.</p>
<h1 id="기본-메서드의-충돌-해결하기"><a href="#기본-메서드의-충돌-해결하기" class="headerlink" title="기본 메서드의 충돌 해결하기"></a>기본 메서드의 충돌 해결하기</h1><p>Java에서 하나의 클래스는 여러 인터페이스를 구현할 수 있다. Java 8 이전에는 여러 인터페이스가 같은 메서드를 갖더라도 어차피 구현은 클래스에서만 제공했기 때문에 문제가 되지 않았다. 하지만 Java 8에서 인터페이스들이 각각 동일한 메서드의 기본 구현을 제공하고, 클래스에서 충돌이 발생하는 메서드를 명시적으로 오버라이드 하지 않으면 컴파일러가 어떤 기본 메서드를 사용해야할 지 선택할 수 없기 때문에 문제가 발생한다. 책에 나와있는 예시를 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Identified</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Math.abs(hashCode()); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Person</span>, <span class="title">Identified</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Person</code>과 <code>Identified</code> 인터페이스는 <code>getId()</code> 기본 메서드를 정의하고 있고, <code>Employee</code> 클래스는 두 인터페이스를 구현한다. <code>Employee</code> 클래스에서 <code>getId()</code>를 오버라이드 하지 않으면 <strong>Employee inherits unrelated defaults for getId() from types Person and Identified</strong> 라는 컴파일 에러가 발생한다.</p>
<p>한 쪽에서 기본 메서드를 구현하지 않으면 문제가 해결될까? <code>Identified</code>를 아래와 같이 기본 메서드 구현을 하지 않도록 바꾸고 컴파일 해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Identified</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>될 것 같지만 메시지가 <strong>Employee is not abstract and does not override abstract method getId() in Identified</strong> 라고 바뀔 뿐 여전히 컴파일은 되지 않는다. <code>Person</code>과 <code>Identified</code> 인터페이스가 동일한 메서드를 갖고 있긴 하지만 컴파일러 입장에서는 두 개가 정말 같은 목적의 메서드인지 알 길이 없다. 따라서 같은 모양의 메서드지만 두 메서드를 다른 것으로 보고 클래스가 <code>Identified</code>를 구현하지 않았다고 판단한다.(개인적으로는 이것이 일관성이 부족하다고 생각하는데 그 이유는 두 인터페이스 모두 기본 메서드를 구현하지 않는 경우에는 충돌이 일어나지 않기 때문이다.)</p>
<p>가장 좋은 해결 방안은 충돌이 나는 경우를 만들지 않는 것이다. 두 인터페이스가 동일한 메서드를 갖고 있다면 인터페이스 간에 상속 관계가 있지는 않은지, 메서드 이름을 너무 포괄적으로 정한 것은 아닌지 따져보고 충돌 상황을 피하는 게 좋다.</p>
<p>메서드 이름이나 기본 메서드 구현을 포기하지 않고 컴파일 에러를 해결하는 방법은 아래와 같다.</p>
<h2 id="클래스에서-충돌-메서드-구현"><a href="#클래스에서-충돌-메서드-구현" class="headerlink" title="클래스에서 충돌 메서드 구현"></a>클래스에서 충돌 메서드 구현</h2><p>가장 단순한 방법으로 클래스에서 충돌 메서드의 구현을 덮어 버리는 것이다. 이 때 클래스에서 구현을 새로 할 수도 있지만 어느 한 쪽의 기본 메서드를 사용할 수도 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Person</span>, <span class="title">Identified</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Person의 기본 메서드를 사용하고 싶은 경우.</span></div><div class="line">        <span class="comment">// Identified의 기본 메서드를 사용하려면 Identified.super.getId()를 반환한다.</span></div><div class="line">        <span class="keyword">return</span> Person.<span class="keyword">super</span>.getId();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="인터페이스간-상속"><a href="#인터페이스간-상속" class="headerlink" title="인터페이스간 상속"></a>인터페이스간 상속</h2><p><code>Person</code> 인터페이스가 <code>Identified</code>를 상속받도록 하면 <code>Employee</code>에 구현 메서드가 없어도 문제를 해결할 수 있다. 하지만 이런 결정을 하기 전에 인터페이스 사이의 관계를 잘 고려해야한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Identified</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Identified</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Math.abs(hashCode()); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이렇게 하면 <code>Employee</code>는 결국 <code>Person</code>의 기본 메서드를 사용하게 된다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;요즘 &lt;a href=&quot;http://www.yes24.com/24/goods/23449538?scode=032&amp;amp;OzSrank=1&quot;&gt;카이 호스트만의 코어 자바8&lt;/a&gt;로 Java 8을 공부하고 있다. 작년 초에 개발자로 전향하여 Java 8의 stream 같은 것을 &lt;del&gt;매우 신기해하며&lt;/del&gt; 어깨너머로 배워 사용했었는데 알고보니 Java 8이 처음 출시된 것은 2014년 3월 18일이었다.(&lt;a href=&quot;https://www.java.com/ko/download/faq/release_dates.xml&quot;&gt;Java 릴리스 페이지 참고&lt;/a&gt;) 지금은 Java 9가 나오려고 몸을 들썩이는 중이다. Java 8을 제대로 공부도 해보지 않았는데 벌써 Java 9가 나온다고 하니 젊은 나이에 뒤처지는 것 같은 기분이 들었다. 이런 까닭에 황급히 서점에서 책을 사서 공부하는 중이다. 원저의 제목 &lt;a href=&quot;https://www.amazon.com/Core-Java-Impatient-Cay-Horstmann/dp/0321996321&quot;&gt;Core Java for the Impatient&lt;/a&gt;가 내 상황에 잘 들어맞는 것 같다. 오랜만에 블로그에 글도 올릴 겸 더 늦기 전에 Java 8을 공부하면서 중요하다고 생각하는 것들을 정리해보려고 한다.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>가상 머신으로 Hadoop-2.7.2 클러스터 구성하기</title>
    <link href="http://yoursite.com/2016-03-23/hadoop-2-7-2-cluster-with-vagrant-virtual-machines/"/>
    <id>http://yoursite.com/2016-03-23/hadoop-2-7-2-cluster-with-vagrant-virtual-machines/</id>
    <published>2016-03-23T14:50:00.000Z</published>
    <updated>2017-01-16T01:27:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>부서 배치를 받고 일주일, 말로만 듣던 하둡을 만져 볼 기회가 찾아왔다. 나는 기술 교육 기간동안 일찍 출근하던 습관이 몸에 배어서 지금도 규정 출근 시각보다 30~40분 정도 일찍 회사에 도착한다.(평생 그런 적이 없었는데 이번에 이직을 하면서 그런 인간이 되었다.) 일찍 일어나는 새가 벌레를 잡듯, 일찍 출근하니 일찍 출근하시는 이사님께서 과제를 주셨다 ㅎㅎㅎ 이사님께 받은 과제가 바로 가상 머신을 이용하여 하둡 클러스터 구성하기이다. <a id="more"></a></p>
<h1 id="가상-머신-준비"><a href="#가상-머신-준비" class="headerlink" title="가상 머신 준비"></a>가상 머신 준비</h1><p><a href="https://www.vagrantup.com/" target="_blank" rel="external">Vagrant</a> 를 이용하면 편리하게 여러 대의 가상 머신을 생성할 수 있다. <a href="https://www.vagrantup.com/" target="_blank" rel="external">Vagrant</a> 가 편리하긴 하지만 역시 공짜는 없다. 배워야 한다. 그래도 한번 배워두면 두고두고 편리하게 이용할 수 있으니 직접 가상 머신을 생성하고 띄우는 것 보다는 낫다.</p>
<p>VirtualBox가 설치되어 있으면 다음과 같은 <a href="https://www.vagrantup.com/" target="_blank" rel="external">Vagrant</a> 명령어로 CentOS-6.5 가상 머신을 띄울 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vagrant init puphpet/centos65-x64; vagrant up --provider virtualbox</div></pre></td></tr></table></figure>
<p><code>puphpet/centos65-x64</code> 은 <a href="https://atlas.hashicorp.com/boxes/search" target="_blank" rel="external">Vagrant Boxes</a>에서 찾은 CentOS-6.5 이미지이다. 우분투나 여타 다른 OS 이미지도 여기서 찾아서 사용할 수 있다. <code>vagrant init</code> 명령어를 사용하면 명령어를 실행한 위치에 <code>.vagrant/</code> 디렉터리와 <code>Vagrantfile</code> 이라는 설정 파일이 생성된다.</p>
<p><a href="https://www.vagrantup.com/" target="_blank" rel="external">Vagrant</a> 를 배우는 것은 결국 이 설정 파일을 구성하는 법을 배우는 것이다. 설정 파일은 <a href="https://www.ruby-lang.org/ko/" target="_blank" rel="external">Ruby</a> 의 문법을 따른다. 알고보니 <a href="https://www.vagrantup.com/" target="_blank" rel="external">Vagrant</a> 도 <a href="https://www.ruby-lang.org/ko/" target="_blank" rel="external">Ruby</a> 로 작성된 프로젝트였다.(시간나면 배워야겠다.)</p>
<p>나의 목적은 여러 대의 가상 머신으로 하둡 클러스터를 구성하는 것이므로 한 번에 여러 대의 머신을 띄워야 한다. <a href="https://www.vagrantup.com/" target="_blank" rel="external">Vagrant</a> 도 이제 막 써보는 단계이고, <a href="https://www.ruby-lang.org/ko/" target="_blank" rel="external">Ruby</a> 도 몰라서 어떻게 하면 되는지 구글에게 물어봤다. 결국 다음과 같은 구성을 얻게 되었다.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">boxes = [</div><div class="line">  &#123;</div><div class="line">    <span class="symbol">:name</span> =&gt; <span class="string">"master"</span>,</div><div class="line">    <span class="symbol">:eth1</span> =&gt; <span class="string">"192.168.33.10"</span>,</div><div class="line">    <span class="symbol">:mem</span> =&gt; <span class="string">"512"</span>,</div><div class="line">    <span class="symbol">:cpu</span> =&gt; <span class="string">"1"</span>,</div><div class="line">    <span class="symbol">:ssh_port</span> =&gt; <span class="string">"2260"</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="symbol">:name</span> =&gt; <span class="string">"slave1"</span>,</div><div class="line">    <span class="symbol">:eth1</span> =&gt; <span class="string">"192.168.33.12"</span>,</div><div class="line">    <span class="symbol">:mem</span> =&gt; <span class="string">"512"</span>,</div><div class="line">    <span class="symbol">:cpu</span> =&gt; <span class="string">"1"</span>,</div><div class="line">    <span class="symbol">:ssh_port</span> =&gt; <span class="string">"2280"</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="symbol">:name</span> =&gt; <span class="string">"slave2"</span>,</div><div class="line">    <span class="symbol">:eth1</span> =&gt; <span class="string">"192.168.33.13"</span>,</div><div class="line">    <span class="symbol">:mem</span> =&gt; <span class="string">"512"</span>,</div><div class="line">    <span class="symbol">:cpu</span> =&gt; <span class="string">"1"</span>,</div><div class="line">    <span class="symbol">:ssh_port</span> =&gt; <span class="string">"2290"</span></div><div class="line">  &#125;</div><div class="line">]</div><div class="line"></div><div class="line">Vagrant.configure(<span class="number">2</span>) <span class="keyword">do</span> <span class="params">|config|</span></div><div class="line">  config.vm.box = <span class="string">"puphpet/centos65-x64"</span></div><div class="line"></div><div class="line">  config.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|v, override|</span></div><div class="line">    override.vm.box = <span class="string">"puphpet/centos65-x64"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  boxes.each <span class="keyword">do</span> <span class="params">|opts|</span></div><div class="line">    config.vm.define opts[<span class="symbol">:name</span>] <span class="keyword">do</span> <span class="params">|config|</span></div><div class="line">      config.vm.hostname = opts[<span class="symbol">:name</span>]</div><div class="line"></div><div class="line">      config.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|v|</span></div><div class="line">        v.customize [<span class="string">"modifyvm"</span>, <span class="symbol">:id</span>, <span class="string">"--memory"</span>, opts[<span class="symbol">:mem</span>]]</div><div class="line">        v.customize [<span class="string">"modifyvm"</span>, <span class="symbol">:id</span>, <span class="string">"--cpus"</span>, opts[<span class="symbol">:cpu</span>]]</div><div class="line">      <span class="keyword">end</span></div><div class="line"></div><div class="line">      config.vm.network <span class="symbol">:private_network</span>, <span class="symbol">ip:</span> opts[<span class="symbol">:eth1</span>]</div><div class="line">      config.vm.network <span class="string">"forwarded_port"</span>, <span class="symbol">guest:</span> <span class="number">22</span>, <span class="symbol">host:</span> opts[<span class="symbol">:ssh_port</span>], <span class="symbol">id:</span> <span class="string">"ssh"</span>, <span class="symbol">auto_correct:</span> <span class="literal">true</span></div><div class="line"></div><div class="line">      config.ssh.port = opts[<span class="symbol">:ssh_port</span>]</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p><code>puphpet/centos65-x64</code> 이미지로 서버를 만들면 vagrant 계정이 만들어진다. 비밀번호는 vagrant이고 이 계정으로 <code>sudo</code> 명령어를 수행할 수 있다. 이렇게 구성을 마치고 <code>$ vagrant up</code> 명령어를 수행하면 가상 머신 세 대가 생성되고 실행된다. 각 머신은 hadoop에서 다음 역할을 수행한다.</p>
<p><strong>master: namenode</strong><br><strong>slave1: datanode</strong><br><strong>slave2: datanode</strong></p>
<p>그럼 이제 하둡 클러스터를 구성해보자.</p>
<h1 id="준비-사항-모든-머신"><a href="#준비-사항-모든-머신" class="headerlink" title="준비 사항(모든 머신)"></a>준비 사항(모든 머신)</h1><p>ssh, sshd, rsync, java를 설치해야 한다. ssh, sshd는 CentOS-6.5에 포함되어 있으므로 java만 설치하도록 하자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo yum install -y java-1.7.0-openjdk-devel</div></pre></td></tr></table></figure>
<p>하둡은 $JAVA_HOME 변수를 참조한다. 나는 <code>/etc/profile.d/hadoop.sh</code> 에서 $JAVA_HOME 변수를 export 하도록 하였다. 하둡은 IPv6 network를 지원하지 않는다. 두번째 변수는 IPv4를 사용하도록 java 파라미터를 넣어준다. 마지막 줄에서는 hadoop 설정 파일의 위치를 지정해준다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$JAVA_HOME</span>"</span> = <span class="string">""</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.95.x86_64</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$HADOOP_OPTS</span>"</span> = <span class="string">""</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">export</span> HADOOP_OPTS=-Djava.net.preferIPv4Stack=<span class="literal">true</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$HADOOP_CONF_DIR</span>"</span> = <span class="string">""</span> ]</div><div class="line"><span class="keyword">then</span></div><div class="line">    <span class="built_in">export</span> HADOOP_CONF_DIR=/opt/hadoop/hadoop/etc/hadoop</div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<h1 id="계정-생성-모든-머신"><a href="#계정-생성-모든-머신" class="headerlink" title="계정 생성(모든 머신)"></a>계정 생성(모든 머신)</h1><p>hadoop을 실행할 계정을 만들자(계정 이름이 hadoop이 아니어도 된다.)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo useradd hadoop</div><div class="line">$ sudo passwd hadoop</div></pre></td></tr></table></figure>
<h1 id="서버간-ssh-접속-설정-모든-머신"><a href="#서버간-ssh-접속-설정-모든-머신" class="headerlink" title="서버간 ssh 접속 설정(모든 머신)"></a>서버간 ssh 접속 설정(모든 머신)</h1><p>서버간 비밀번호 입력없이 ssh 접속을 할 수 있게 설정해야 한다. 우선 서버끼리 이름으로 접속할 수 있도록 <code>/etc/hosts</code> 파일을 수정하자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">192.168.33.10 master</div><div class="line">192.168.33.11 secondary</div><div class="line">192.168.33.12 slave1</div><div class="line">192.168.33.13 slave2</div></pre></td></tr></table></figure>
<p>호스트 파일(ex. master 머신)에 <code>127.0.0.1 master localhost ...</code> 이런 내용이 있을 수 있다. <code>127.0.0.1 master</code> 는 나중에 문제가 될 수 있으므로 <code>127.0.0.1 master</code>는 지워주자. <code>127.0.0.1 localhost</code> 는 지우지 않아도 된다. 아니면 마음 편히 기존에 있던 내용은 다 지우고 위와 같이 설정해줘도 된다.</p>
<p><code>/etc/hosts</code> 파일 설정이 완료되었으면 1에서 생성한 계정으로 바꾸어 서버마다 key를 생성하고 공유해줘야 한다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ su hadoop</div><div class="line">$ ssh-keygen -t rsa</div><div class="line">$ ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop@master</div><div class="line">$ ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop@slave1</div><div class="line">$ ssh-copy-id -i ~/.ssh/id_rsa.pub hadoop@slave2</div><div class="line">$ chmod 0600 ~/.ssh/authorized_keys</div><div class="line">$ <span class="built_in">exit</span></div></pre></td></tr></table></figure>
<p><strong>※ 자기 자신도 ssh로 접속할 수 있도록 모든 머신에 위 명령어를 실행해야 한다.</strong></p>
<h1 id="Hadoop-2-7-2-설치-master만"><a href="#Hadoop-2-7-2-설치-master만" class="headerlink" title="Hadoop-2.7.2 설치(master만)"></a>Hadoop-2.7.2 설치(master만)</h1><p>이제 하둡을 설치해 보자. 설치 경로는 달라도 상관 없다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ sudo mkdir /opt/hadoop</div><div class="line">$ <span class="built_in">cd</span> /opt/hadoop/</div><div class="line">$ sudo wget http://apache.mirror.cdnetworks.com/hadoop/common/hadoop-2.7.2/hadoop-2.7.2.tar.gz</div><div class="line">$ sudo tar -xzf hadoop-2.7.2.tar.gz</div><div class="line">$ sudo mv hadoop-1.2.0 hadoop</div><div class="line">$ sudo chown -R hadoop /opt/hadoop</div><div class="line">$ <span class="built_in">cd</span> /opt/hadoop/hadoop/</div></pre></td></tr></table></figure>
<h1 id="Hadoop-공통-설정-master만"><a href="#Hadoop-공통-설정-master만" class="headerlink" title="Hadoop 공통 설정(master만)"></a>Hadoop 공통 설정(master만)</h1><p><strong><code>core-site.xml</code></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ su hadoop</div><div class="line">$ <span class="built_in">cd</span> /opt/hadoop/hadoop</div><div class="line">$ vi etc/hadoop/core-site.xml</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://master:9000/<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.permissions<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong><code>hdfs-site.xml</code></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi etc/hadoop/hdfs-site.xml</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/hadoop/hadoop/hdfs/namenode<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/hadoop/hadoop/hdfs/datanode<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong><code>yarn-site.xml</code></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi etc/hadoop/yarn-site.xml</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8030<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8032<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8088<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8031<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.admin.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8033<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
<p>여기까지 하고 설치한 하둡 디렉터리 통째로 slave1, slave2에 복사해주자.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> /opt/hadoop</div><div class="line">$ scp -r hadoop hadoop-slave-1:/opt/hadoop</div><div class="line">$ scp -r hadoop hadoop-slave-2:/opt/hadoop</div></pre></td></tr></table></figure>
<h1 id="Hadoop-마스터-설정-master만"><a href="#Hadoop-마스터-설정-master만" class="headerlink" title="Hadoop 마스터 설정(master만)"></a>Hadoop 마스터 설정(master만)</h1><p>4에서 설정한 파일들은 master 머신에서만 수정을 하긴 했지만 namenode든 datanode든 공통적으로 필요한 내용이라 설정한 내용을 모두 slave1, slave2에 복사하였다. 이제는 master에 필요한 설정을 해주자.</p>
<p><strong><code>mapred-site.xml</code></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi etc/hadoop/mapred-site.xml</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobtracker.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:9001<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong><code>slave</code></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi etc/hadoop/slave</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">slave1</div><div class="line">slave2</div></pre></td></tr></table></figure>
<h1 id="하둡-클러스터-구동-master만"><a href="#하둡-클러스터-구동-master만" class="headerlink" title="하둡 클러스터 구동(master만)"></a>하둡 클러스터 구동(master만)</h1><p><strong>Namenode 포맷</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/hdfs namenode -format</div></pre></td></tr></table></figure>
<p><strong>Distributed Format System 시작</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sbin/start-dfs.sh</div></pre></td></tr></table></figure>
<p><strong>YARN MapReduce Job Tracker 시작</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sbin/start-yarn.sh</div></pre></td></tr></table></figure>
<h1 id="동작-확인"><a href="#동작-확인" class="headerlink" title="동작 확인"></a>동작 확인</h1><p>PC에서 <a href="http://192.168.33.10:50070" target="_blank" rel="external">http://192.168.33.10:50070</a> 으로 정상적으로 접속되는지 확인해보자. Namenode와 Datanode가 정상적으로 연동 된다면 <code>Live Nodes</code> 라는 칸에 Datanode의 개수 2가 표시된다.</p>
<h2 id="WordCount-예제-실행"><a href="#WordCount-예제-실행" class="headerlink" title="WordCount 예제 실행"></a>WordCount 예제 실행</h2><p><a href="https://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html" target="_blank" rel="external">WordCount</a>는 프로그래밍 기초로 치면 “Hello, World” 예제라고 볼 수 있다. 링크를 따라가 예제를 실행해보자.</p>
<p>다음과 같은 결과를 얻는다면 성공이다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ bin/hadoop fs -cat /user/hadoop/wordcount/output/*</div><div class="line">Bye 1</div><div class="line">Goodbye 1</div><div class="line">Hadoop 2</div><div class="line">Hello 2</div><div class="line">World 2</div></pre></td></tr></table></figure>
<p>위에 내가 적어둔대로 한다고 100% 하둡 클러스터가 문제없이 동작할 것이라는 보장은 없다. 아마 제대로 동작하지 않을 확률이 더 높을 것이다. 내가 쓴 글이 잘못되었을 수도 있고, 따라하는 과정에서 실수가 있을 수 있다. 나도 여러 튜토리얼을 보고 따라했지만 그대로 되진 않았다. 하둡 클러스터를 구성하면서 배운 점은 잘 안되면 무조건 로그를 봐야 한다는 것이다. 나는 이 클러스터를 구성하는데 이틀이 걸렸다. <code>jps</code> 를 쳐보면 namenode의 프로세스도 잘 떠있고, datanode의 프로세스도 잘 떠 있는데도 namenode에서 datanode를 인식하지 못했다. 답답한 마음에 구글님께 여쭤봤지만 같은 문제라도 원인은 천차만별이었다. 결국 로그를 뒤져보니 datanode에서 namenode로 연결이 안되는 문제였다. 이 문제는 namenode의 <code>/etc/hosts</code> 파일의 127.0.0.1 master를 지우면서 해결되었다. 클러스터 구성에 문제가 생겼다면 구글에게 물어보기 전에 로그를 한 번 열어보자 :)</p>
<h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p><a href="https://chawlasumit.wordpress.com/2015/03/09/install-a-multi-node-hadoop-cluster-on-ubuntu-14-04/" target="_blank" rel="external">https://chawlasumit.wordpress.com/2015/03/09/install-a-multi-node-hadoop-cluster-on-ubuntu-14-04/</a><br><a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/SingleCluster.html" target="_blank" rel="external">http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/SingleCluster.html</a><br><a href="http://mudchobo.tistory.com/541" target="_blank" rel="external">http://mudchobo.tistory.com/541</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;부서 배치를 받고 일주일, 말로만 듣던 하둡을 만져 볼 기회가 찾아왔다. 나는 기술 교육 기간동안 일찍 출근하던 습관이 몸에 배어서 지금도 규정 출근 시각보다 30~40분 정도 일찍 회사에 도착한다.(평생 그런 적이 없었는데 이번에 이직을 하면서 그런 인간이 되었다.) 일찍 일어나는 새가 벌레를 잡듯, 일찍 출근하니 일찍 출근하시는 이사님께서 과제를 주셨다 ㅎㅎㅎ 이사님께 받은 과제가 바로 가상 머신을 이용하여 하둡 클러스터 구성하기이다.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>학습 테스트를 작성하자!</title>
    <link href="http://yoursite.com/2016-03-13/training-test/"/>
    <id>http://yoursite.com/2016-03-13/training-test/</id>
    <published>2016-03-13T14:50:00.000Z</published>
    <updated>2017-01-16T01:27:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>프로젝트를 진행하다보면 새로운 API나 사용해 본 적 없는 라이브러리를 사용해야 하는 때가 찾아온다. 기존 프로젝트에서 사용해 본 익숙한 라이브러리라면 API를 어떻게 사용하면 되고, 이 API가 어떻게 동작할 지 예측할 수 있다. 하지만 처음 사용해 보는 것이라면 얘기가 다르다. 이 라이브러리가 프로젝트의 요구사항에 부합하는지, 예상한 대로 동작하는지 확인해 볼 필요가 있다. 이런 경우에 개발자들은 어떻게 라이브러리를 검증해야 할까? <a id="more"></a> 다음과 같은 선택지가 있다.</p>
<ol>
<li>제품 코드에 직접 적용하여 테스트 해본다.</li>
<li>연습용 프로젝트를 만들어서 테스트 해본다.</li>
<li><strong>학습 테스트를 작성한다.</strong></li>
</ol>
<p>1, 2번은 나같이 경험이 적은 개발자들이 쉽게 생각할 수 있는 선택지이다. 1번에 대해 얘기해보자. 이미 잘 동작하는 코드도 있고, 내가 주로 하는 일이 이 프로젝트를 실행시켜서 디버깅하는 일이다. 자주 수정하고, 실행해보던 코드에 새로운 라이브러리를 적용해보면 라이브러리의 동작을 빨리 확인해 볼 수 있다. 탈없이 라이브러리의 기능을 확인하고 라이브러리가 예상과 같이 동작한다면 제품에 바로 적용이 되므로 좋을 것 같다. 하지만 개발자에게 이러한 행운이 따르리란 보장은 없다. 보통은 새로운 API를 사용하는 데 서툴러 이것 저것 고치게 된다. 그러다보면 기존에 잘 동작하던 코드까지 망칠 수 있으므로 좋은 방법이라 볼 수 없다.</p>
<p>2번은 어떨까. 우선 1번의 문제는 피해갈 수 있다. 예제용 프로젝트를 따로 만들어서 테스트하면 기존 프로젝트에 영향은 없다. 예제 프로젝트를 새로 만드는 것이 어려운 것도 아니다. IDE를 몇 번 클릭하면 새로운 프로젝트가 뚝딱 생겨난다. 하지만 이 방법도 그리 영리한 것이라고 볼 순 없다. 실제 프로젝트는 많은 라이브러리와 직접 작성한 모듈들이 맞물려 동작한다. 실제 프로젝트와 같은 환경의 예제 프로젝트를 만드는 것은 생각보다 간단한 일이 아닐 수 있다. 실제 프로젝트와 같은 환경을 구축하는 데 시간을 허비하면 그만큼 테스트 코드를 작성하는 시간이 줄어든다. 또한 예제 프로젝트는 관리가 어렵다는 단점이 있다. 예제 프로젝트를 버전 관리 시스템에 올려 놓기는 조금 찝찝하다. 그렇다고 로컬에만 저장해놓으면 팀원들과 공유도 되지 않고, 시간이 지나면 자신도 그 존재를 잊게 될 것이다.</p>
<p>1, 2번의 문제를 깔끔하게 해결할 수 있는 것이 바로 학습 테스트를 작성하는 것이다. 학습 테스트는 말그대로 새로운 라이브러리를 학습 하기 위한 테스트이다. 테스트 코드는 다른 단위 테스트, 통합 테스트 코드와 마찬가지로 프로젝트 내에서 작성한다. 다른 테스트와 차이라면 내가 작성한 모듈이 아닌 외부 라이브러리의 동작을 확인하는 데 쓰인 다는 것이다. 테스트 코드는 테스트 할 때만 동작하므로 제품 코드의 동작에 전혀 영향을 주지 않는다.<br><em>(사실 가끔 테스트 코드가 제품 코드에 영향을 주기도 한다. 만약 제품 코드가 테스트하기 어려운 구조로 작성되어 있다면 테스트하기 쉽도록 리팩토링을 해줘야 한다. 이것은 옳은 방향이므로 학습 테스트의 부작용이라고 할 순 없다.)</em><br>또한 학습 테스트는 실제 프로젝트 안에 작성하게 되므로 실제 프로젝트와 같은 환경을 만드려는 노력을 하지 않아도 된다. 테스트 내에서 기존에 쓰던 라이브러리와 기존에 작성된 모듈을 그대로 사용할 수 있으므로 연습용 프로젝트를 만드는 것 보다 더 정확한 테스트를 수행할 수 있다. 마지막으로 학습 테스트는 프로젝트의 자산이 된다는 장점이 있다. 실제 프로젝트 내에 존재하므로 학습 테스트도 버전 관리가 가능하다. 그러면 필요에 따라 학습 테스트에 추가적인 케이스를 추가할 수 있고, 팀원들과 공유도 가능해진다. 테스트하고자 하는 라이브러리의 새 버전이 릴리즈되었을 때도 학습 테스트는 유용하게 쓰인다. 새 버전이 이전 버전과 호환이 되는지, 우리 팀이 기대하는 대로 동작하는지 학습 테스트가 알아서 해준다.</p>
<p>위와 같이 학습 테스트는 장점이 아주 많다. 문제는 나처럼 경험이 적은 개발자들이 학습 테스트를 작성하는 데 익숙하지 않다는 것이다. 다른 사람이 작성한 라이브러리를 우리 프로젝트에서 테스트 한다는 것이 조금 생소할 수 있다. 이제부터 익숙해지면 된다. 프로젝트는 내가 책임져야 하므로 내가 테스트를 해야 한다. 그리고 위와 같이 장점이 많은데도 학습 테스트를 작성하지 않을 이유가 없다. 혹시 지금 1, 2번과 같은 작업을 하고 있다면 다시 생각해보자. 그리고 학습 테스트를 작성하자!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;프로젝트를 진행하다보면 새로운 API나 사용해 본 적 없는 라이브러리를 사용해야 하는 때가 찾아온다. 기존 프로젝트에서 사용해 본 익숙한 라이브러리라면 API를 어떻게 사용하면 되고, 이 API가 어떻게 동작할 지 예측할 수 있다. 하지만 처음 사용해 보는 것이라면 얘기가 다르다. 이 라이브러리가 프로젝트의 요구사항에 부합하는지, 예상한 대로 동작하는지 확인해 볼 필요가 있다. 이런 경우에 개발자들은 어떻게 라이브러리를 검증해야 할까?
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>엔티티(Entity)와 값 객체(Value Object)의 차이</title>
    <link href="http://yoursite.com/2016-02-06/difference-between-entity-and-value-object/"/>
    <id>http://yoursite.com/2016-02-06/difference-between-entity-and-value-object/</id>
    <published>2016-02-05T17:33:00.000Z</published>
    <updated>2017-01-16T01:27:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.yes24.com/24/goods/13159413?scode=032&amp;OzSrank=2" target="_blank" rel="external">자바 웹 개발 워크북</a>을 공부하면서 값 객체(Value Object)라는 개념을 처음 보게 되었다. 책에서는 값 객체를 값을 전달하는 역할을 하는 객체라고 설명한다. 개념을 소개하는 부분에서는 그런 개념이구나 하고 넘어갔는데 책의 중반부로 가니 예제에서 DB 테이블과 매핑되는 모든 객체들을 값 객체로 다루고 있었다. <a id="more"></a>  MVC에서 Model에 해당되는 부분이 단지 DB에서 값만 읽어 오는 역할 밖에 못하나 하는 생각이 들었다. 예전에 .NET Framework 기반에서 개발을 할 때는 ORM 프레임워크에서 테이블과 매핑해주는 객체를 엔티티(Entity)라고 불렀다. 같은 개념을 Java에서는 값 객체라 하고, .NET 에서는 엔티티라고 부르는 것일까? 이런 의문들이 생겨 구글에 검색해보니 명쾌하게 설명해주는 글이 있었다. 이 글이 신빙성이 있는지 확신은 할 수 없지만 구글에서 ‘difference between entity and value object’라고 검색했을 때 가장 위에 위치한 것을 보아 충분히 읽어볼 만한 글이라 생각한다. 그리고 내가 공부삼아 굳이 번역을 하긴 했지만 원문이 어렵지 않으므로 되도록 원문을 읽어보길 바란다.</p>
<hr>
<p><a href="http://culttt.com/2014/04/30/difference-entities-value-objects/" target="_blank" rel="external">원문 보기</a></p>
<p>여러분은 컴퓨터 프로그래밍을 하면 할 수록 엄청나게 많은 새로운 이론과 개념들을 맞닥뜨리게 된다. 그 중에서 직관적으로 이해되지 않는 하나는 바로 값 객체(Value Object)이다. 값 객체는 도메인 주도 설계(Domain Driven Design)에서 중요한 개념이다.당장 도메인 주도 설계에 대해 잘 모른다 하더라도 이 글을 이해하는 데 문제는 없다. 이 글은 값 객체를 설명하는 데 초점을 두고 있다. 하지만 이 글이 여러분이 추후 도메인 주도 설계를 이해하는 첫 걸음이 되기를 희망한다.</p>
<p>참고: 이 글은 여러분이 객체 지향 프로그래밍(Object Oriented Programming)에 대해 잘 알고 있다고 가정한다. 그렇지 않다면 객체 지향 프로그래밍에 대해 먼저 학습하고 오길 바란다.</p>
<h2 id="엔티티-vs-값-객체"><a href="#엔티티-vs-값-객체" class="headerlink" title="엔티티 vs 값 객체"></a>엔티티 vs 값 객체</h2><p>객체 지향 프로그래밍에서는 관련된 속성과 메서드를 객체로 표현한다. 예를 들어, 어플리케이션 상에서 사람은 객체가 될 수 있다. 사람은 이름, 이메일, 비밀번호 등 많은 속성을 지닌다. 데이터베이스에서는 이 사람을 <code>id</code> 로 식별한다. 이는 사람이 자신의 이름, 이메일, 비밀번호를 바꾸더라도 <code>id</code> 가 바뀌지 않으면 같은 사람임을 의미한다. 이렇게 속성이 바뀌더라도 여전히 같은 것으로 인식되는 객체를 엔티티라고 한다. 엔티티는 속성이 바뀔 수 있기 때문에 가변(mutable) 객체다. 엔티티의 정체성은 <code>id</code> 로 표현된다.</p>
<p>우리 어플리케이션이 사람의 현재 위치를 기록할 수 있다고 상상해보자. 그 사람이 성공적으로 인터넷에 연결하고 우리 어플리케이션에 인증을 하면 새로운 위치 객체가 생성된다. 위치 객체는 위도와 경도 값을 가진다. 우리는 위치 객체가 어떤 위치 정보를 담고 있는지에만 관심이 있기 때문에 위치 객체는 값 객체가 된다.</p>
<p>어떤 사람의 위치가 바뀌었을 때 우리는 기존의 위치 객체를 갱신하지 않는다. 단순히 새로운 위치 객체를 생성한다. 위치 객체는 생성된 이후로 소멸될 때까지 자신의 속성을 변경하지 않는다. 객체의 속성이 바뀔 수 없을 때, 그 객체를 불변(immutable) 객체라고 한다.</p>
<p>또한 값 객체는 식별자에 의해 같음(equality)이 결정되지 않는다. 예를 들어 당신이 같은 위도와 경도를 가진 위치 객체를 두 개 생성했다면 그 두 객체는 같은 객체이다. 반면에 사람 객체는 <code>id</code> 라는 고유한 식별자로 같음을 판단한다. 같은 이름을 가진 두 개의 사람 객체가 있다고 해도 두 객체는 같지 않을 수 있다.</p>
<h2 id="어떻게-값-객체를-식별할까"><a href="#어떻게-값-객체를-식별할까" class="headerlink" title="어떻게 값 객체를 식별할까?"></a>어떻게 값 객체를 식별할까?</h2><p>이제 우리는 어떤 객체가 <code>id</code> 로 식별된다면 엔티티로, 그렇지 않다면 값 객체라고 구분할 수 있다. 엔티티의 속성은 바뀔 수 있다. 하지만 엔티티는 고유한 식별자로 표현되기 때문에 우리 시스템 상에서 같은 객체로 인식된다. 반면 값 객체는 갖고 있는 값으로표현되는 객체이다. 한번 생성되면 그 값을 바꿀 수 없으며, 우리는 그것이 어떤 개체인지 신경쓰지 않는다.</p>
<p>언제 엔티티를 쓰고, 값 객체를 써야할지 어떻게 알 수 있을까? 그것은 어플리케이션의 상황에 따라 결정된다. 처음 예시로 돌아가보자. 우리 어플리케이션은 더이상 단순한 소셜 서비스가 아니다. 포스퀘어와 동일 다고 가정해보자. 모든 위치 객체는 고유한 식별자를 지닌다. 많은 사람들이 같은 위치에서 체크인을 할 수 있기 때문이다. 이제 위치 객체는 더이상 값 객체가 아닌 엔티티가 된다.</p>
<p>예제를 바꿔보자. 우리가 파워 플랜트의 소유자라고 상상해보라. 파워 플랜트는 철책(securify fence) 주변에서 일어나는 모든 활동을 기록한다. 감시의 목적으로 철책 주변의 많은 위치에서 활동이 기록된다. 이 때 우리는 특정 위치에서 일어나는 활동에 대해 관심이 있기 때문에 철책 주변의 위치는 엔티티가 된다. 수상한 사람이 우리가 감시하는 위치로 들어오게 되면 그 사건은 데이터베이스에 저장된다. 이 예제에서 사람은 값 객체이다. 우리는 감시중인 위치에 들어 온 사람이 어떤 사람인지 관심이 없기 때문이다. 단지 그 사람이 감시중인 위치에 걸려들었을 뿐이다.</p>
<p>위의 예제와 보았듯 어떤 객체가 엔티티인지 값 객체인지는 여러분의 어플리케이션이 그것을 어떻게 사용할 것인지에 달려있다. 일반적으로 위치, 날짜, 숫자, 금액은 값 객체인 경우가 많다. 그리고 사람, 제품, 파일, 판매는 엔티티인 경우가 대부분이다.</p>
<h2 id="왜-값-객체와-엔티티를-구분하는-것이-중요할까"><a href="#왜-값-객체와-엔티티를-구분하는-것이-중요할까" class="headerlink" title="왜 값 객체와 엔티티를 구분하는 것이 중요할까?"></a>왜 값 객체와 엔티티를 구분하는 것이 중요할까?</h2><p>여러분은 <strong>왜 값 객체와 엔티티의 구분이 중요할까?</strong> 하고 생각할지 모른다. 이것은 다음과 같은 이유로 매우 중요하다.</p>
<p>첫 번째로, 여러분이 같은 속성을 가진 두 개의 엔티티를 갖고 있을 때, 두 객체는 다른 <code>id</code> 를 갖고 있기 때문에 같지 않다. 하지만 같은 속성을 가진 두 값 객체를 갖고 있는 경우에 이 두 객체는 같은 객체이므로 두 객체를 자유롭게 바꿔서 쓸 수 있다. 한 객체를 다른 객체로 대체할 수 있을 때 그 객체는 값 객체이다. 반면 엔티티는 다른 것으로 교체할 경우 원치않는 부작용이 발생하게 된다.</p>
<p>두 번째로, 오랜 시간동안 엔티티의 속성은 변하지만 여전히 그것은 같은 엔티티이다. 어떤 사용자가 자신의 이메일 주소를 변경하는 것이 그 예이다. 하지만 어플리케이션이 값 객체의 속성을 변경하려고 할 때, 그 객체는 사라지고 새로운 객체가 대신하게 된다. 결제를 할 때 당신이 냈던 돈이 거스름돈이 되어 다시 돌아오지 않는다. 당신은 낮은 금액의 새로운 돈 객체를 받는다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>엔티티와 값 객체의 차이는 도메인 주도 설계에서 중요한 개념이다. 우리가 어플리케이션에서 실제 세계를 모델링할 때 이 차이는 아주 중요하다. 이 글에서 언급했듯이 여러분이 어떤 것을 개발하는지 이해하는 것이 중요하다. 어떤 어플리케이션을 만드냐에 따라 어떤 객체가 엔티티가 될지 값 객체가 될지 결정된다. 언뜻 보기에 어떤 객체가 식별자를 가져야 할 것 같다고 해서 무작정 그것을 엔티티로 만들면 안된다. 불변 객체가 되어야 할 개념을 엔티티로 모델링하면 원치 않는 부작용이 발생할 수 있다.</p>
<p>불변 객체는 어플리케이션이 의도한 대로 동작하게 하는 중요한 요소이다. 돈과 같은 것을 모델링할 때 값 객체를 사용하면 그것이 시간에 따라 변하지 않는다는 것을 보장해준다.</p>
<p>엔티티와 값 객체의 차이가 항상 뚜렷하지는 않다. 때로 그 차이를 구분하는 것은 여러분이 만들고자 하는 어플리케이션에 대한 완벽한 이해를 요구한다. 하지만 실제 세계를 여러분의 코드로 모델링하는 데 있어 엔티티와 값 객체의 차이를 아는 것은 매우 중요하다.</p>
<hr>
<p><a href="http://www.yes24.com/24/goods/13159413?scode=032&amp;OzSrank=2" target="_blank" rel="external">자바 웹 개발 워크북</a>은 Spring 프레임워크를 이해하는 데 아주 좋은 책이라고 생각한다. 하지만 이런 사소해보이지만 중요한 개념을 설명하는 데는 다소 소홀하지 않았나 하는 생각이 든다. 저자가 그런 것 까지 설명하면 책의 내용이 방대해질까 걱정되어 어물쩍 넘어 간 것일 수도 있겠다.</p>
<p>하지만 이런 내용을 잘못 이해하면 엉뚱한 방향으로 개발할 수 있다. 책의 예제를 보고 모든 DB와 매핑된 객체들을 값 객체로 오인하면 한 속성만 바꾸어 저장해도 될 일을 매번 객체를 생성하게 되고, 그 객체를 관리하는 다른 클래스를 만들게 될 수도 있다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.yes24.com/24/goods/13159413?scode=032&amp;amp;OzSrank=2&quot;&gt;자바 웹 개발 워크북&lt;/a&gt;을 공부하면서 값 객체(Value Object)라는 개념을 처음 보게 되었다. 책에서는 값 객체를 값을 전달하는 역할을 하는 객체라고 설명한다. 개념을 소개하는 부분에서는 그런 개념이구나 하고 넘어갔는데 책의 중반부로 가니 예제에서 DB 테이블과 매핑되는 모든 객체들을 값 객체로 다루고 있었다.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2016년이 밝았다</title>
    <link href="http://yoursite.com/2016-01-09/happy-new-year/"/>
    <id>http://yoursite.com/2016-01-09/happy-new-year/</id>
    <published>2016-01-09T06:50:00.000Z</published>
    <updated>2017-01-16T01:27:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>2016년이 밝았다. 올해로 다시 개발자가 되었다. 2010년 8월부터 2013년 7월까지 산업기능요원으로 복무를 한 이후로 2년반만에 개발자라는 타이틀을 되찾은 것이다. 이렇게 되기까지 많은 고민이 있었다. 나는 산업공학을 전공했고, 졸업 후 1년 간은 제조업 회사에서 일을 했다. 졸업 후 진로를 선택할 때 개발자가 되는 것을 전혀 고려하지 않았던 것은 아니다. 오히려 뛰어난 프로그래머에 대한 동경심이 있었다. <a id="more"></a> 하지만 그때는  산업공학 전공자로서 제조업에서 일하는 것이 더 좋을 것이라는 막연한 생각과 나는 좋은 프로그래머가 되지 못할 것 같다는 생각에 다른 길을 선택하게 되었다.</p>
<p>이전 회사에서도 IT 관련 부서에서 일을 했었다. 하지만 대부분의 업무는 외주업체 개발자를 관리하는 것이었고, 직접 코드를 작성하는 경우는 드물었다. 내가 직접 코드를 작성할 때는 내 노력여하에 따라 결과의 퀄리티나 업무 일정이 결정될 수 있었는데, 개발자를 관리하는 역할을 맡게 되니 중간 전달자 노릇만 하게 되고 뭔가 답답한 느낌만 들었다. 그러다보니 예전에 직접 코드를 짜던 시절이 생각나기 시작한 것이다. 산업기능요원으로 일했던 기억이 아름다운 추억처럼 포장되어 머리 속에 떠올랐다. 배우는 즐거움이 있었고, 해결 못할 것 같은 과제를 해낼 때의 짜릿함이 있었다. 물론 프로그래밍 문법 하나 제대로 이해하지 못해 버그를 만든 적도 있었고, 팀장한테 탈탈 털려서 밤새 한숨도 못잔 적도 있었다. 하지만 평생 외주 개발자 관리하는 일이나 하는 것보다 내가 만든 버그로 혼나는 것이 좋겠다는 생각이 들었다.</p>
<p>감사하게도 올해는 좋은 기회를 얻어 개발자로 일할 수 있게 되었다. 아직도 내가 좋은 개발자가 될 수 있을거란 확신은 없다. 그래도 오랜 고민 끝에 선택한 업이니 마음을 단단히 먹기로 했다. 그런 의미에서 올해 목표를 세워보았다.(목표를 달성하려면 다른 사람에게 알리는 것이 좋다고 한다 ㅎㅎ)</p>
<ol>
<li>한 달에 한 권 이상 기술 서적 읽기.</li>
<li>한 달에 한 권 이상 교양 서적 읽기.</li>
<li>한 달에 한 번 이상 블로그에 글 쓰기.</li>
<li>이틀에 한 번 30분 이상 운동하기.</li>
</ol>
<p>목표를 적는 순간부터 부담이 되지만 잘 지키기만 한다면 괜찮은 2016년을 보낼 것 같다. 좋은 개발자로 한 걸음 내딛는 올해가 되길…<br><strong>Happy New Year!</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016년이 밝았다. 올해로 다시 개발자가 되었다. 2010년 8월부터 2013년 7월까지 산업기능요원으로 복무를 한 이후로 2년반만에 개발자라는 타이틀을 되찾은 것이다. 이렇게 되기까지 많은 고민이 있었다. 나는 산업공학을 전공했고, 졸업 후 1년 간은 제조업 회사에서 일을 했다. 졸업 후 진로를 선택할 때 개발자가 되는 것을 전혀 고려하지 않았던 것은 아니다. 오히려 뛰어난 프로그래머에 대한 동경심이 있었다.
    
    </summary>
    
    
  </entry>
  
</feed>
